Index: src/test/java/com/atlassian/theplugin/commons/fisheye/api/rest/FishEyeServerFacadeTest.java
===================================================================
--- src/test/java/com/atlassian/theplugin/commons/fisheye/api/rest/FishEyeServerFacadeTest.java	(revision 24291)
+++ src/test/java/com/atlassian/theplugin/commons/fisheye/api/rest/FishEyeServerFacadeTest.java	(working copy)
@@ -1,8 +1,18 @@
 package com.atlassian.theplugin.commons.fisheye.api.rest;
 
+import static org.easymock.EasyMock.createMock;
+import static org.easymock.EasyMock.replay;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+import junit.framework.TestCase;
+
+import org.easymock.EasyMock;
+
+import com.atlassian.theplugin.commons.cfg.FishEyeServer;
 import com.atlassian.theplugin.commons.cfg.FishEyeServerCfg;
 import com.atlassian.theplugin.commons.cfg.ServerId;
-import com.atlassian.theplugin.commons.cfg.FishEyeServer;
 import com.atlassian.theplugin.commons.configuration.ConfigurationFactory;
 import com.atlassian.theplugin.commons.configuration.PluginConfigurationBean;
 import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
@@ -11,14 +21,7 @@
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException;
 import com.atlassian.theplugin.crucible.api.rest.CharArrayEquals;
-import junit.framework.TestCase;
-import org.easymock.EasyMock;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.replay;
 
-import java.util.Arrays;
-import java.util.Collection;
-
 /**
  * User: pmaruszak
  */
@@ -44,6 +47,12 @@
 			public FishEyeSession getSession(final String url) throws RemoteApiMalformedUrlException {
 				return fishEyeSessionMock;
 			}
+			
+			@Override
+			public FishEyeSession getSession(FishEyeServer server)
+					throws RemoteApiMalformedUrlException {
+				return fishEyeSessionMock;
+			}
 		};
 	}
 
Index: src/main/java/com/atlassian/theplugin/commons/remoteapi/ProductServerFacade.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/remoteapi/ProductServerFacade.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/remoteapi/ProductServerFacade.java	(working copy)
@@ -17,9 +17,18 @@
 package com.atlassian.theplugin.commons.remoteapi;
 
 import com.atlassian.theplugin.commons.ServerType;
+import com.atlassian.theplugin.commons.cfg.ServerCfg;
 
 public interface ProductServerFacade {
+
+	void testServerConnection(ServerCfg serverCfg) throws RemoteApiException;
+
+	@Deprecated
+	/**
+	 * For testing only
+	 */
 	void testServerConnection(String url, String userName, String password) throws RemoteApiException;
 
+	
 	ServerType getServerType();
 }
Index: src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallback.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallback.java	(revision 0)
+++ src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallback.java	(revision 0)
@@ -0,0 +1,21 @@
+package com.atlassian.theplugin.commons.remoteapi.rest;
+
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpMethod;
+
+import com.atlassian.theplugin.commons.cfg.Server;
+import com.atlassian.theplugin.commons.exception.HttpProxySettingsException;
+
+/**
+ * Interface for the callback used by AbstractHttpSession for HttpClient setup
+ * 
+ * @author Shawn Minto
+ *
+ */
+public interface HttpSessionCallback {
+
+	HttpClient getHttpClient(Server server) throws HttpProxySettingsException;
+
+	void configureHttpMethod(AbstractHttpSession session, HttpMethod method);
+	
+}

Property changes on: src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallback.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Index: src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallbackImpl.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallbackImpl.java	(revision 0)
+++ src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallbackImpl.java	(revision 0)
@@ -0,0 +1,25 @@
+package com.atlassian.theplugin.commons.remoteapi.rest;
+
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpMethod;
+
+import com.atlassian.theplugin.commons.cfg.Server;
+import com.atlassian.theplugin.commons.exception.HttpProxySettingsException;
+import com.atlassian.theplugin.commons.util.HttpClientFactory;
+
+/**
+ * Default implementation of the {@link HttpSessionCallback}
+ * 
+ * @author Shawn Minto
+ */
+public class HttpSessionCallbackImpl implements HttpSessionCallback {
+
+	public HttpClient getHttpClient(Server server) throws HttpProxySettingsException {
+		return HttpClientFactory.getClient();
+	}
+	
+	public void configureHttpMethod(AbstractHttpSession session, HttpMethod method) {
+		session.adjustHttpHeader(method);
+	}
+
+}

Property changes on: src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/HttpSessionCallbackImpl.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Index: src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/AbstractHttpSession.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/AbstractHttpSession.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/remoteapi/rest/AbstractHttpSession.java	(working copy)
@@ -1,359 +1,365 @@
-/**
- * Copyright (C) 2008 Atlassian
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.atlassian.theplugin.commons.remoteapi.rest;
-
-import com.atlassian.theplugin.commons.exception.HttpProxySettingsException;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiSessionExpiredException;
-import com.atlassian.theplugin.commons.util.HttpClientFactory;
-import com.atlassian.theplugin.commons.util.UrlUtil;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpStatus;
-import org.apache.commons.httpclient.cookie.CookiePolicy;
-import org.apache.commons.httpclient.methods.DeleteMethod;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.StringRequestEntity;
-import org.jdom.Document;
-import org.jdom.Element;
-import org.jdom.JDOMException;
-import org.jdom.input.SAXBuilder;
-import org.jdom.output.Format;
-import org.jdom.output.XMLOutputter;
-import org.jdom.xpath.XPath;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Communication stub for lightweight XML based APIs.
- */
-public abstract class AbstractHttpSession {
-    protected final String baseUrl;
-    protected String userName;
-    protected String password;
-    protected HttpClient client = null;
-
-    private final Object clientLock = new Object();
-
-    private static ThreadLocal<URL> url = new ThreadLocal<URL>();
-
-    // TODO: replace this with a proper cache to ensure automatic purging. Responses can get quite large.
-    private final Map<String, CacheRecord> cache =
-        new HashMap<String, CacheRecord>();
-
-    /**
-     * This class holds an HTTP response body, together with its last
-     * modification time and Etag.
-     */
-    private final class CacheRecord {
-        private final byte[] document;
-        private final String lastModified;
-        private final String etag;
-
-        private CacheRecord(byte[] document, String lastModified, String etag) {
-            if (document == null || lastModified == null || etag == null) {
-                throw new IllegalArgumentException("null");
-            } else {
-                this.document = document;
-                this.lastModified = lastModified;
-                this.etag = etag;
-            }
-        }
-
-        public byte[] getDocument() {
-            return document;
-        }
-
-        public String getLastModified() {
-            return lastModified;
-        }
-
-        public String getEtag() {
-            return etag;
-        }
-    }
-
-    public static URL getUrl() {
-        return url.get();
-    }
-
-	public static void setUrl(final URL urlString) {
-		url.set(urlString);
-	}
-
-	public static void setUrl(final String urlString) throws MalformedURLException {
-		setUrl(new URL(urlString));
-	}
-
-	/**
-     * Public constructor for AbstractHttpSession
-     *
-     * @param baseUrl base URL for server instance
-     * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
-     *          for malformed url
-     */
-    public AbstractHttpSession(String baseUrl) throws RemoteApiMalformedUrlException {
-
-        this.baseUrl = UrlUtil.removeUrlTrailingSlashes(baseUrl);
-
-        try {
-            UrlUtil.validateUrl(baseUrl);
-        } catch (MalformedURLException e) {
-            throw new RemoteApiMalformedUrlException("Malformed server URL: " + baseUrl, e);
-        }
-    }
-
-    protected Document retrieveGetResponse(String urlString)
-            throws IOException, JDOMException, RemoteApiSessionExpiredException {
-
-        byte[] result = doConditionalGet(urlString);
-        Document doc;
-
-		SAXBuilder builder = new SAXBuilder();
-		doc = builder.build(new ByteArrayInputStream(result));
-
-//		XmlUtil.printXml(doc);
-
-		preprocessResult(doc);
-
-		return doc;
-    }
-
-    protected byte[] doConditionalGet(String urlString) throws IOException, JDOMException, RemoteApiSessionExpiredException {
-
-        UrlUtil.validateUrl(urlString);
-		setUrl(urlString);
-		synchronized (clientLock) {
-            if (client == null) {
-                try {
-                    client = HttpClientFactory.getClient();
-                } catch (HttpProxySettingsException e) {
-                    throw (IOException) new IOException("Connection error. Please set up HTTP Proxy settings").initCause(e);
-                }
-            }
-
-            GetMethod method = new GetMethod(urlString);
-
-            CacheRecord cacheRecord = cache.get(urlString);
-            if (cacheRecord != null) {
-//                System.out.println(String.format("%s in cache, adding If-Modified-Since: %s and If-None-Match: %s headers.",
-//                    urlString, cacheRecord.getLastModified(), cacheRecord.getEtag()));
-                method.addRequestHeader("If-Modified-Since", cacheRecord.getLastModified());
-                method.addRequestHeader("If-None-Match", cacheRecord.getEtag());
-            }
-            try {
-                method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);
-                method.getParams().setSoTimeout(client.getParams().getSoTimeout());
-                adjustHttpHeader(method);
-
-                client.executeMethod(method);
-
-                if (method.getStatusCode() == HttpStatus.SC_NOT_MODIFIED && cacheRecord != null) {
-//					System.out.println("Cache record valid, using cached value: " + new String(cacheRecord.getDocument()));
-                    return cacheRecord.getDocument().clone();
-                } else if (method.getStatusCode() != HttpStatus.SC_OK) {
-
-					throw new IOException(
-                            "HTTP " + method.getStatusCode() + " (" + HttpStatus.getStatusText(method.getStatusCode())
-                                    + ")\n" + method.getStatusText());
-                } else {
-//					System.out.println("Received GET response document.");
-                    final byte[] result = method.getResponseBody();
-                    final String lastModified = method.getResponseHeader("Last-Modified") == null ? null
-							: method.getResponseHeader("Last-Modified").getValue();
-                    final String eTag = method.getResponseHeader("Etag") == null ? null 
-							: method.getResponseHeader("Etag").getValue();
-
-                    if (lastModified != null && eTag != null) {
-                        cacheRecord = new CacheRecord(result, lastModified, eTag);
-                        cache.put(urlString, cacheRecord);
-//						System.out.println("Latest GET response document placed in cache: " + new String(result));
-                    }
-                    return result.clone();
-                }
-            } catch (NullPointerException e) {
-                throw (IOException) new IOException("Connection error").initCause(e);
-            } finally {
-                method.releaseConnection();
-            }
-        }
-
-
-	}
-
-    protected byte[] retrieveGetResponseAsBytes(String urlString)
-            throws IOException, JDOMException, RemoteApiSessionExpiredException {
-        return doConditionalGet(urlString);
-    }
-
-    protected Document retrievePostResponse(String urlString, Document request)
-            throws IOException, JDOMException, RemoteApiSessionExpiredException {
-        return retrievePostResponse(urlString, request, true);
-    }
-
-    protected Document retrievePostResponse(String urlString, Document request, boolean expectResponse)
-            throws IOException, JDOMException, RemoteApiSessionExpiredException {
-        XMLOutputter serializer = new XMLOutputter(Format.getPrettyFormat());
-        String requestString = serializer.outputString(request);
-        return retrievePostResponse(urlString, requestString, expectResponse);
-    }
-
-    protected Document retrievePostResponse(String urlString, String request, boolean expectResponse)
-            throws IOException, JDOMException, RemoteApiSessionExpiredException {
-        UrlUtil.validateUrl(urlString);
-		setUrl(urlString);
-		Document doc = null;
-        synchronized (clientLock) {
-            if (client == null) {
-                try {
-                    client = HttpClientFactory.getClient();
-                } catch (HttpProxySettingsException e) {
-                    throw (IOException) new IOException("Connection error. Please set up HTTP Proxy settings").initCause(e);
-                }
-            }
-
-            PostMethod method = new PostMethod(urlString);
-
-            try {
-                method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);
-                method.getParams().setSoTimeout(client.getParams().getSoTimeout());
-                adjustHttpHeader(method);
-
-                if (request != null && !"".equals(request)) {
-                    method.setRequestEntity(
-                            new StringRequestEntity(request, "application/xml", "UTF-8"));
-                }
-
-                client.executeMethod(method);
-
-                final int httpStatus = method.getStatusCode();
-                if (httpStatus == HttpStatus.SC_NO_CONTENT) {
-					return doc;
-				} else if (httpStatus != HttpStatus.SC_OK
-                        && httpStatus != HttpStatus.SC_CREATED) {
-
-					Document document;
-					SAXBuilder builder = new SAXBuilder();
-					document = builder.build(method.getResponseBodyAsStream());
-
-					throw new IOException(buildExceptionText(method.getStatusCode(), document));
-                }
-
-                if (expectResponse) {
-                    SAXBuilder builder = new SAXBuilder();
-                    doc = builder.build(method.getResponseBodyAsStream());
-                    preprocessResult(doc);
-                }
-            } catch (NullPointerException e) {
-                throw (IOException) new IOException("Connection error").initCause(e);
-            } finally {
-                method.releaseConnection();
-            }
-        }
-        return doc;
-    }
-
-	private String buildExceptionText(final int statusCode, final Document document) throws JDOMException {
-		String text = "Server returned HTTP " + statusCode + " (" + HttpStatus.getStatusText(statusCode) + ")\n"
-				+ "Reason: ";
-
-		XPath xpath = XPath.newInstance("error/code");
-		@SuppressWarnings("unchecked")
-		final List<Element> nodes = xpath.selectNodes(document);
-		if (nodes != null && !nodes.isEmpty()) {
-//			System.out.println(nodes.get(0).getValue());
-			text += nodes.get(0).getValue() + " ";
-		}
-
-//		xpath = XPath.newInstance("error/stacktrace");
-//		nodes = xpath.selectNodes(document);
-//		if (nodes != null && !nodes.isEmpty()) {
-////			System.out.println(nodes.get(0).getValue());
-//		}
-
-		return text;
-	}
-
-
-	protected Document retrieveDeleteResponse(String urlString, boolean expectResponse)
-            throws IOException, JDOMException, RemoteApiSessionExpiredException {
-        UrlUtil.validateUrl(urlString);
-
-        Document doc = null;
-        synchronized (clientLock) {
-            if (client == null) {
-                try {
-                    client = HttpClientFactory.getClient();
-                } catch (HttpProxySettingsException e) {
-                    throw (IOException) new IOException("Connection error. Please set up HTTP Proxy settings").initCause(e);
-                }
-            }
-
-            DeleteMethod method = new DeleteMethod(urlString);
-
-            try {
-                method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);
-                method.getParams().setSoTimeout(client.getParams().getSoTimeout());
-                adjustHttpHeader(method);
-
-                client.executeMethod(method);
-
-				if (method.getStatusCode() == HttpStatus.SC_NO_CONTENT) {
-					return null;
-				}
-				if (method.getStatusCode() != HttpStatus.SC_OK) {
-                    throw new IOException("HTTP status code " + method.getStatusCode() + ": " + method.getStatusText());
-                }
-
-                if (expectResponse) {
-                    SAXBuilder builder = new SAXBuilder();
-                    doc = builder.build(method.getResponseBodyAsStream());
-                    preprocessResult(doc);
-                }
-            } catch (NullPointerException e) {
-                throw (IOException) new IOException("Connection error").initCause(e);
-            } finally {
-                method.releaseConnection();
-            }
-        }
-        return doc;
-    }
-
-
-    protected abstract void adjustHttpHeader(HttpMethod method);
-
-    protected abstract void preprocessResult(Document doc) throws JDOMException, RemoteApiSessionExpiredException;
-
-    public static String getServerNameFromUrl(String urlString) {
-        int pos = urlString.indexOf("://");
-        if (pos != -1) {
-            urlString = urlString.substring(pos + 1 + 2);
-        }
-        pos = urlString.indexOf("/");
-        if (pos != -1) {
-            urlString = urlString.substring(0, pos);
-        }
-        return urlString;
-    }
-}
+/**
+ * Copyright (C) 2008 Atlassian
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.atlassian.theplugin.commons.remoteapi.rest;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpMethod;
+import org.apache.commons.httpclient.HttpStatus;
+import org.apache.commons.httpclient.cookie.CookiePolicy;
+import org.apache.commons.httpclient.methods.DeleteMethod;
+import org.apache.commons.httpclient.methods.GetMethod;
+import org.apache.commons.httpclient.methods.PostMethod;
+import org.apache.commons.httpclient.methods.StringRequestEntity;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.jdom.xpath.XPath;
+
+import com.atlassian.theplugin.commons.cfg.Server;
+import com.atlassian.theplugin.commons.exception.HttpProxySettingsException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiSessionExpiredException;
+import com.atlassian.theplugin.commons.util.UrlUtil;
+
+/**
+ * Communication stub for lightweight XML based APIs.
+ */
+public abstract class AbstractHttpSession {
+    protected final String baseUrl;
+    protected String userName;
+    protected String password;
+    protected HttpClient client = null;
+	private HttpSessionCallback callback;
+	private Server server;
+	
+    private final Object clientLock = new Object();
+
+    private static ThreadLocal<URL> url = new ThreadLocal<URL>();
+
+    // TODO: replace this with a proper cache to ensure automatic purging. Responses can get quite large.
+    private final Map<String, CacheRecord> cache =
+        new HashMap<String, CacheRecord>();
+        
+    /**
+     * This class holds an HTTP response body, together with its last
+     * modification time and Etag.
+     */
+    private final class CacheRecord {
+        private final byte[] document;
+        private final String lastModified;
+        private final String etag;
+
+        private CacheRecord(byte[] document, String lastModified, String etag) {
+            if (document == null || lastModified == null || etag == null) {
+                throw new IllegalArgumentException("null");
+            } else {
+                this.document = document;
+                this.lastModified = lastModified;
+                this.etag = etag;
+            }
+        }
+
+        public byte[] getDocument() {
+            return document;
+        }
+
+        public String getLastModified() {
+            return lastModified;
+        }
+
+        public String getEtag() {
+            return etag;
+        }
+    }
+
+    public static URL getUrl() {
+        return url.get();
+    }
+
+	public static void setUrl(final URL urlString) {
+		url.set(urlString);
+	}
+
+	public static void setUrl(final String urlString) throws MalformedURLException {
+		setUrl(new URL(urlString));
+	}
+
+	/**
+     * Public constructor for AbstractHttpSession
+     *
+     * @param baseUrl base URL for server instance
+     * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
+     *          for malformed url
+     */
+    public AbstractHttpSession(Server server, HttpSessionCallback callback) throws RemoteApiMalformedUrlException {
+    	this.server = server;
+    	this.callback = callback;
+    	String baseUrl = server.getUrl();
+    	
+        this.baseUrl = UrlUtil.removeUrlTrailingSlashes(baseUrl);
+
+        try {
+            UrlUtil.validateUrl(baseUrl);
+        } catch (MalformedURLException e) {
+            throw new RemoteApiMalformedUrlException("Malformed server URL: " + baseUrl, e);
+        }
+    }
+
+    protected Document retrieveGetResponse(String urlString)
+            throws IOException, JDOMException, RemoteApiSessionExpiredException {
+
+        byte[] result = doConditionalGet(urlString);
+        Document doc;
+
+		SAXBuilder builder = new SAXBuilder();
+		doc = builder.build(new ByteArrayInputStream(result));
+
+//		XmlUtil.printXml(doc);
+
+		preprocessResult(doc);
+
+		return doc;
+    }
+
+    protected byte[] doConditionalGet(String urlString) throws IOException, JDOMException, RemoteApiSessionExpiredException {
+
+        UrlUtil.validateUrl(urlString);
+		setUrl(urlString);
+		synchronized (clientLock) {
+            if (client == null) {
+                try {
+                    client = callback.getHttpClient(server);
+                } catch (HttpProxySettingsException e) {
+                    throw (IOException) new IOException("Connection error. Please set up HTTP Proxy settings").initCause(e);
+                }
+            }
+
+            GetMethod method = new GetMethod(urlString);
+
+            CacheRecord cacheRecord = cache.get(urlString);
+            if (cacheRecord != null) {
+//                System.out.println(String.format("%s in cache, adding If-Modified-Since: %s and If-None-Match: %s headers.",
+//                    urlString, cacheRecord.getLastModified(), cacheRecord.getEtag()));
+                method.addRequestHeader("If-Modified-Since", cacheRecord.getLastModified());
+                method.addRequestHeader("If-None-Match", cacheRecord.getEtag());
+            }
+            try {
+                method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);
+                method.getParams().setSoTimeout(client.getParams().getSoTimeout());
+                callback.configureHttpMethod(this, method);
+
+                client.executeMethod(method);
+
+                if (method.getStatusCode() == HttpStatus.SC_NOT_MODIFIED && cacheRecord != null) {
+//					System.out.println("Cache record valid, using cached value: " + new String(cacheRecord.getDocument()));
+                    return cacheRecord.getDocument().clone();
+                } else if (method.getStatusCode() != HttpStatus.SC_OK) {
+
+					throw new IOException(
+                            "HTTP " + method.getStatusCode() + " (" + HttpStatus.getStatusText(method.getStatusCode())
+                                    + ")\n" + method.getStatusText());
+                } else {
+//					System.out.println("Received GET response document.");
+                    final byte[] result = method.getResponseBody();
+                    final String lastModified = method.getResponseHeader("Last-Modified") == null ? null
+							: method.getResponseHeader("Last-Modified").getValue();
+                    final String eTag = method.getResponseHeader("Etag") == null ? null 
+							: method.getResponseHeader("Etag").getValue();
+
+                    if (lastModified != null && eTag != null) {
+                        cacheRecord = new CacheRecord(result, lastModified, eTag);
+                        cache.put(urlString, cacheRecord);
+//						System.out.println("Latest GET response document placed in cache: " + new String(result));
+                    }
+                    return result.clone();
+                }
+            } catch (NullPointerException e) {
+                throw (IOException) new IOException("Connection error").initCause(e);
+            } finally {
+                method.releaseConnection();
+            }
+        }
+
+
+	}
+
+    protected byte[] retrieveGetResponseAsBytes(String urlString)
+            throws IOException, JDOMException, RemoteApiSessionExpiredException {
+        return doConditionalGet(urlString);
+    }
+
+    protected Document retrievePostResponse(String urlString, Document request)
+            throws IOException, JDOMException, RemoteApiSessionExpiredException {
+        return retrievePostResponse(urlString, request, true);
+    }
+
+    protected Document retrievePostResponse(String urlString, Document request, boolean expectResponse)
+            throws IOException, JDOMException, RemoteApiSessionExpiredException {
+        XMLOutputter serializer = new XMLOutputter(Format.getPrettyFormat());
+        String requestString = serializer.outputString(request);
+        return retrievePostResponse(urlString, requestString, expectResponse);
+    }
+
+    protected Document retrievePostResponse(String urlString, String request, boolean expectResponse)
+            throws IOException, JDOMException, RemoteApiSessionExpiredException {
+        UrlUtil.validateUrl(urlString);
+		setUrl(urlString);
+		Document doc = null;
+        synchronized (clientLock) {
+            if (client == null) {
+                try {
+                	client = callback.getHttpClient(server);
+                } catch (HttpProxySettingsException e) {
+                    throw (IOException) new IOException("Connection error. Please set up HTTP Proxy settings").initCause(e);
+                }
+            }
+
+            PostMethod method = new PostMethod(urlString);
+
+            try {
+                method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);
+                method.getParams().setSoTimeout(client.getParams().getSoTimeout());
+                callback.configureHttpMethod(this, method);
+
+                if (request != null && !"".equals(request)) {
+                    method.setRequestEntity(
+                            new StringRequestEntity(request, "application/xml", "UTF-8"));
+                }
+
+                client.executeMethod(method);
+
+                final int httpStatus = method.getStatusCode();
+                if (httpStatus == HttpStatus.SC_NO_CONTENT) {
+					return doc;
+				} else if (httpStatus != HttpStatus.SC_OK
+                        && httpStatus != HttpStatus.SC_CREATED) {
+
+					Document document;
+					SAXBuilder builder = new SAXBuilder();
+					document = builder.build(method.getResponseBodyAsStream());
+
+					throw new IOException(buildExceptionText(method.getStatusCode(), document));
+                }
+
+                if (expectResponse) {
+                    SAXBuilder builder = new SAXBuilder();
+                    doc = builder.build(method.getResponseBodyAsStream());
+                    preprocessResult(doc);
+                }
+            } catch (NullPointerException e) {
+                throw (IOException) new IOException("Connection error").initCause(e);
+            } finally {
+                method.releaseConnection();
+            }
+        }
+        return doc;
+    }
+
+	private String buildExceptionText(final int statusCode, final Document document) throws JDOMException {
+		String text = "Server returned HTTP " + statusCode + " (" + HttpStatus.getStatusText(statusCode) + ")\n"
+				+ "Reason: ";
+
+		XPath xpath = XPath.newInstance("error/code");
+		@SuppressWarnings("unchecked")
+		final List<Element> nodes = xpath.selectNodes(document);
+		if (nodes != null && !nodes.isEmpty()) {
+//			System.out.println(nodes.get(0).getValue());
+			text += nodes.get(0).getValue() + " ";
+		}
+
+//		xpath = XPath.newInstance("error/stacktrace");
+//		nodes = xpath.selectNodes(document);
+//		if (nodes != null && !nodes.isEmpty()) {
+////			System.out.println(nodes.get(0).getValue());
+//		}
+
+		return text;
+	}
+
+
+	protected Document retrieveDeleteResponse(String urlString, boolean expectResponse)
+            throws IOException, JDOMException, RemoteApiSessionExpiredException {
+        UrlUtil.validateUrl(urlString);
+
+        Document doc = null;
+        synchronized (clientLock) {
+            if (client == null) {
+                try {
+                	client = callback.getHttpClient(server);
+                } catch (HttpProxySettingsException e) {
+                    throw (IOException) new IOException("Connection error. Please set up HTTP Proxy settings").initCause(e);
+                }
+            }
+
+            DeleteMethod method = new DeleteMethod(urlString);
+
+            try {
+                method.getParams().setCookiePolicy(CookiePolicy.RFC_2109);
+                method.getParams().setSoTimeout(client.getParams().getSoTimeout());
+                callback.configureHttpMethod(this, method);
+
+                client.executeMethod(method);
+
+				if (method.getStatusCode() == HttpStatus.SC_NO_CONTENT) {
+					return null;
+				}
+				if (method.getStatusCode() != HttpStatus.SC_OK) {
+                    throw new IOException("HTTP status code " + method.getStatusCode() + ": " + method.getStatusText());
+                }
+
+                if (expectResponse) {
+                    SAXBuilder builder = new SAXBuilder();
+                    doc = builder.build(method.getResponseBodyAsStream());
+                    preprocessResult(doc);
+                }
+            } catch (NullPointerException e) {
+                throw (IOException) new IOException("Connection error").initCause(e);
+            } finally {
+                method.releaseConnection();
+            }
+        }
+        return doc;
+    }
+
+
+    protected abstract void adjustHttpHeader(HttpMethod method);
+
+    protected abstract void preprocessResult(Document doc) throws JDOMException, RemoteApiSessionExpiredException;
+
+    public static String getServerNameFromUrl(String urlString) {
+        int pos = urlString.indexOf("://");
+        if (pos != -1) {
+            urlString = urlString.substring(pos + 1 + 2);
+        }
+        pos = urlString.indexOf("/");
+        if (pos != -1) {
+            urlString = urlString.substring(0, pos);
+        }
+        return urlString;
+    }
+}
Index: src/main/java/com/atlassian/theplugin/commons/crucible/CrucibleServerFacade.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/crucible/CrucibleServerFacade.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/crucible/CrucibleServerFacade.java	(working copy)
@@ -1,167 +1,170 @@
-/**
- * Copyright (C) 2008 Atlassian
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.atlassian.theplugin.commons.crucible;
-
-import com.atlassian.theplugin.commons.cfg.CrucibleServerCfg;
-import com.atlassian.theplugin.commons.crucible.api.model.*;
-import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
-import com.atlassian.theplugin.commons.remoteapi.ProductServerFacade;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
-
-import java.util.List;
-import java.util.Set;
-
-public interface CrucibleServerFacade extends ProductServerFacade {
-//	CrucibleVersionInfo getServerVersion(CrucibleServerCfg server)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review createReview(CrucibleServerCfg server, Review review)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review createReviewFromRevision(CrucibleServerCfg server, Review review, List<String> revisions)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	List<Action> getAvailableActions(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	List<Action> getAvailableTransitions(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review addRevisionsToReview(CrucibleServerCfg server, PermId permId, String repository, List<String> revisions)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review addPatchToReview(CrucibleServerCfg server, PermId permId, String repository, String patch)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	CrucibleFileInfo addItemToReview(CrucibleServerCfg server, Review review, NewReviewItem newItem)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<Reviewer> getReviewers(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void addReviewers(CrucibleServerCfg server, PermId permId, Set<String> userName)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void removeReviewer(CrucibleServerCfg server, PermId permId, String userName)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review approveReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review submitReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review summarizeReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review abandonReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review closeReview(CrucibleServerCfg server, PermId permId, String summary)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review recoverReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review reopenReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	Review rejectReview(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void completeReview(CrucibleServerCfg server, PermId permId, boolean complete)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<Review> getAllReviews(CrucibleServerCfg server)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<Review> getReviewsForFilter(CrucibleServerCfg server, PredefinedFilter filter)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<Review> getReviewsForCustomFilter(CrucibleServerCfg server, CustomFilter filter)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review getReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	List<Review> getAllReviewsForFile(CrucibleServerCfg server, String repoName, String path)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	Review createReviewFromPatch(CrucibleServerCfg server, Review review, String patch)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<CrucibleFileInfo> getFiles(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	List<Comment> getComments(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<GeneralComment> getGeneralComments(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId, PermId reviewItemId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	List<GeneralComment> getReplies(CrucibleServerCfg server, PermId permId, PermId commentId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	GeneralComment addGeneralComment(CrucibleServerCfg server, PermId permId, GeneralComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	VersionedComment addVersionedComment(CrucibleServerCfg server, PermId permId, PermId riId, VersionedComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void updateComment(CrucibleServerCfg server, PermId id, Comment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void publishComment(CrucibleServerCfg server, PermId reviewId, PermId commentId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void publishAllCommentsForReview(CrucibleServerCfg server, PermId reviewId)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	GeneralComment addGeneralCommentReply(CrucibleServerCfg server, PermId id, PermId cId, GeneralComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	VersionedComment addVersionedCommentReply(CrucibleServerCfg server, PermId id, PermId cId, VersionedComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-//	void updateReply(CrucibleServerCfg server, PermId id, PermId cId, PermId rId, GeneralComment comment)
-//			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	void removeComment(CrucibleServerCfg server, PermId id, Comment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<User> getUsers(CrucibleServerCfg server)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<Project> getProjects(CrucibleServerCfg server)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<Repository> getRepositories(CrucibleServerCfg server)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	SvnRepository getRepository(CrucibleServerCfg server, String repoName)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-	List<CustomFieldDef> getMetrics(CrucibleServerCfg server, int version)
-			throws RemoteApiException, ServerPasswordNotProvidedException;
-
-}
+/**
+ * Copyright (C) 2008 Atlassian
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.atlassian.theplugin.commons.crucible;
+
+import com.atlassian.theplugin.commons.cfg.CrucibleServerCfg;
+import com.atlassian.theplugin.commons.crucible.api.model.*;
+import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
+import com.atlassian.theplugin.commons.remoteapi.ProductServerFacade;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+
+import java.util.List;
+import java.util.Set;
+
+public interface CrucibleServerFacade extends ProductServerFacade {
+//	CrucibleVersionInfo getServerVersion(CrucibleServerCfg server)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review createReview(CrucibleServerCfg server, Review review)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review createReviewFromRevision(CrucibleServerCfg server, Review review, List<String> revisions)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	List<Action> getAvailableActions(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	List<Action> getAvailableTransitions(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review addRevisionsToReview(CrucibleServerCfg server, PermId permId, String repository, List<String> revisions)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review addPatchToReview(CrucibleServerCfg server, PermId permId, String repository, String patch)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	CrucibleFileInfo addItemToReview(CrucibleServerCfg server, Review review, NewReviewItem newItem)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<Reviewer> getReviewers(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void addReviewers(CrucibleServerCfg server, PermId permId, Set<String> userName)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void removeReviewer(CrucibleServerCfg server, PermId permId, String userName)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review approveReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review submitReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review summarizeReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review abandonReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review closeReview(CrucibleServerCfg server, PermId permId, String summary)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review recoverReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review reopenReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	Review rejectReview(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void completeReview(CrucibleServerCfg server, PermId permId, boolean complete)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<Review> getAllReviews(CrucibleServerCfg server)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<Review> getReviewsForFilter(CrucibleServerCfg server, PredefinedFilter filter)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<Review> getReviewsForCustomFilter(CrucibleServerCfg server, CustomFilter filter)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review getReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	List<Review> getAllReviewsForFile(CrucibleServerCfg server, String repoName, String path)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	Review createReviewFromPatch(CrucibleServerCfg server, Review review, String patch)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<CrucibleFileInfo> getFiles(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	List<Comment> getComments(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<GeneralComment> getGeneralComments(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId, PermId reviewItemId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	List<GeneralComment> getReplies(CrucibleServerCfg server, PermId permId, PermId commentId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	GeneralComment addGeneralComment(CrucibleServerCfg server, PermId permId, GeneralComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	VersionedComment addVersionedComment(CrucibleServerCfg server, PermId permId, PermId riId, VersionedComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void updateComment(CrucibleServerCfg server, PermId id, Comment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void publishComment(CrucibleServerCfg server, PermId reviewId, PermId commentId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void publishAllCommentsForReview(CrucibleServerCfg server, PermId reviewId)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	GeneralComment addGeneralCommentReply(CrucibleServerCfg server, PermId id, PermId cId, GeneralComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	VersionedComment addVersionedCommentReply(CrucibleServerCfg server, PermId id, PermId cId, VersionedComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+//	void updateReply(CrucibleServerCfg server, PermId id, PermId cId, PermId rId, GeneralComment comment)
+//			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	void removeComment(CrucibleServerCfg server, PermId id, Comment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<User> getUsers(CrucibleServerCfg server)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<Project> getProjects(CrucibleServerCfg server)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<Repository> getRepositories(CrucibleServerCfg server)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	SvnRepository getRepository(CrucibleServerCfg server, String repoName)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	List<CustomFieldDef> getMetrics(CrucibleServerCfg server, int version)
+			throws RemoteApiException, ServerPasswordNotProvidedException;
+
+	public void setCallback(HttpSessionCallback callback);
+
+}
Index: src/main/java/com/atlassian/theplugin/commons/crucible/CrucibleServerFacadeImpl.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/crucible/CrucibleServerFacadeImpl.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/crucible/CrucibleServerFacadeImpl.java	(working copy)
@@ -1,465 +1,503 @@
-/**
- * Copyright (C) 2008 Atlassian
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.atlassian.theplugin.commons.crucible;
-
-import com.atlassian.theplugin.commons.ServerType;
-import com.atlassian.theplugin.commons.cfg.CrucibleServerCfg;
-import com.atlassian.theplugin.commons.crucible.api.CrucibleLoginException;
-import com.atlassian.theplugin.commons.crucible.api.CrucibleSession;
-import com.atlassian.theplugin.commons.crucible.api.model.*;
-import com.atlassian.theplugin.commons.crucible.api.rest.CrucibleSessionImpl;
-import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-public final class CrucibleServerFacadeImpl implements CrucibleServerFacade {
-	private Map<String, CrucibleSession> sessions = new HashMap<String, CrucibleSession>();
-
-	private static CrucibleServerFacadeImpl instance;
-	private CrucibleUserCache userCache;
-
-	private CrucibleServerFacadeImpl(CrucibleUserCache userCache) {
-		this.userCache = userCache;
-	}
-
-	public static synchronized CrucibleServerFacade getInstance() {
-		if (instance == null) {
-			instance = new CrucibleServerFacadeImpl(CrucibleUserCacheImpl.getInstance());
-		}
-		return instance;
-	}
-
-	public void setUserCache(CrucibleUserCache newCache) {
-		userCache = newCache;
-	}
-
-	public ServerType getServerType() {
-		return ServerType.CRUCIBLE_SERVER;
-	}
-
-	private synchronized CrucibleSession getSession(CrucibleServerCfg server)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		String key = server.getUrl() + server.getUsername() + server.getPassword();
-		CrucibleSession session = sessions.get(key);
-		if (session == null) {
-			try {
-				session = new CrucibleSessionImpl(server.getUrl());
-				sessions.put(key, session);
-			} catch (RemoteApiException e) {
-				if (server.getPassword().length() > 0) {
-                	throw e;
-            	} else {
-                	throw new ServerPasswordNotProvidedException();
-            	}
-			}
-		}
-		if (!session.isLoggedIn()) {
-			session.login(server.getUsername(), server.getPassword());
-		}
-		return session;
-	}
-
-	private <T extends CommentBean> void fixUserName(CrucibleServerCfg server, T comment) {
-		User u = comment.getAuthor();
-		if (u.getDisplayName() == null || u.getDisplayName().length() == 0) {
-			User newU = userCache.getUser(server, u.getUserName(), true);
-			if (newU != null) {
-				comment.setAuthor(newU);
-			}
-		}
-	}
-
-	/**
-	 * @param serverUrl @see
-	 *                  com.atlassian.theplugin.commons.crucible.remoteapi.soap.CrucibleSessionImpl#constructor(String baseUrl)
-	 * @param userName
-	 * @param password
-	 * @throws com.atlassian.theplugin.commons.crucible.api.CrucibleException
-	 *
-	 */
-	public void testServerConnection(String serverUrl, String userName, String password) throws RemoteApiException {
-		CrucibleSession session = null;
-		session = new CrucibleSessionImpl(serverUrl);
-		session.login(userName, password);
-		try {
-			session.getServerVersion();
-		} catch (RemoteApiException e) {
-
-			if (e.getCause().getMessage().startsWith("HTTP 500")) {
-				throw new CrucibleLoginException(
-						"Atlassian IntelliJ Connector detected a Crucible version older\n"
-						+ "than 1.6. Unfortunately, the plugin will not\n"
-						+ "work with this version of Crucible");
-			}
-		}
-
-
-		session.logout();
-	}
-
-//	public CrucibleVersionInfo getServerVersion(CrucibleServerCfg server)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.getServerVersion();
-//	}
-
-	/**
-	 * Creates new review in Crucible
-	 *
-	 * @param server
-	 * @param review data for new review to create (some fields have to be set e.g. projectKey)
-	 * @return created revew date
-	 * @throws com.atlassian.theplugin.commons.crucible.api.CrucibleException
-	 *          in case of createReview error or CrucibleLoginException in case of login error
-	 */
-	public Review createReview(CrucibleServerCfg server, Review review)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.createReview(review);
-	}
-
-	public Review createReviewFromRevision(
-			CrucibleServerCfg server,
-			Review review,
-			List<String> revisions) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		Review newReview = null;
-		if (!revisions.isEmpty()) {
-			newReview = session.createReviewFromRevision(review, revisions);
-		}
-		return newReview;
-	}
-
-//	public List<Action> getAvailableActions(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.getAvailableActions(permId);
-//	}
-
-//	public List<Action> getAvailableTransitions(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.getAvailableTransitions(permId);
-//	}
-
-	public Review addRevisionsToReview(
-			CrucibleServerCfg server,
-			PermId permId,
-			String repository,
-			List<String> revisions) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		Review review = null;
-		if (!revisions.isEmpty()) {
-			review = session.addRevisionsToReview(permId, repository, revisions);
-		}
-		return review;
-	}
-
-	public Review addPatchToReview(
-			CrucibleServerCfg server,
-			PermId permId,
-			String repository,
-			String patch) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		Review review = session.addPatchToReview(permId, repository, patch);
-		return review;
-	}
-
-//	public CrucibleFileInfo addItemToReview(CrucibleServerCfg server, Review review, NewReviewItem newItem)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.addItemToReview(review, newItem);
-//	}
-
-
-	public void addReviewers(
-			CrucibleServerCfg server,
-			PermId permId,
-			Set<String> userNames) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.addReviewers(permId, userNames);
-	}
-
-	public void removeReviewer(
-			CrucibleServerCfg server,
-			PermId permId,
-			String userName) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.removeReviewer(permId, userName);
-	}
-
-	public Review approveReview(
-			CrucibleServerCfg server,
-			PermId permId) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.approveReview(permId);
-	}
-
-	public Review submitReview(
-			CrucibleServerCfg server,
-			PermId permId) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.submitReview(permId);
-	}
-
-	public Review summarizeReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.summarizeReview(permId);
-	}
-
-	public Review abandonReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.abandonReview(permId);
-	}
-
-	public Review closeReview(CrucibleServerCfg server, PermId permId, String summary)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.closeReview(permId, summary);
-	}
-
-	public Review recoverReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.recoverReview(permId);
-	}
-
-	public Review reopenReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.reopenReview(permId);
-	}
-
-//	public Review rejectReview(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.rejectReview(permId);
-//	}
-
-	public void completeReview(CrucibleServerCfg server, PermId permId, boolean complete)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.completeReview(permId, complete);
-	}
-
-	/**
-	 * Creates new review in Crucible
-	 *
-	 * @param server
-	 * @param review data for new review to create (some fields have to be set e.g. projectKey)
-	 * @param patch  patch to assign with the review
-	 * @return created revew date
-	 * @throws com.atlassian.theplugin.commons.crucible.api.CrucibleException
-	 *          in case of createReview error or CrucibleLoginException in case of login error
-	 */
-	public Review createReviewFromPatch(CrucibleServerCfg server, Review review, String patch)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.createReviewFromPatch(review, patch);
-	}
-
-	public List<CrucibleFileInfo> getFiles(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getFiles(permId);
-	}
-
-//	public List<Comment> getComments(CrucibleServerCfg server, PermId permId)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.getComments(permId);
-//	}
-
-	public List<GeneralComment> getGeneralComments(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getGeneralComments(permId);
-	}
-
-	public List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getAllVersionedComments(permId);
-	}
-
-	public List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId, PermId reviewItemId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getVersionedComments(permId, reviewItemId);
-	}
-
-	public List<GeneralComment> getReplies(CrucibleServerCfg server, PermId permId, PermId commentId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getReplies(permId, commentId);
-	}
-
-	public GeneralComment addGeneralComment(CrucibleServerCfg server, PermId permId, GeneralComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		GeneralCommentBean newComment = (GeneralCommentBean) session.addGeneralComment(permId, comment);
-		fixUserName(server, newComment);
-		return newComment;
-	}
-
-	public VersionedComment addVersionedComment(CrucibleServerCfg server, PermId permId, PermId riId, VersionedComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		VersionedCommentBean newComment = (VersionedCommentBean) session.addVersionedComment(permId, riId, comment);
-		fixUserName(server, newComment);
-		return newComment;
-	}
-
-	public void updateComment(CrucibleServerCfg server, PermId id, Comment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.updateComment(id, comment);
-	}
-
-	public void publishComment(CrucibleServerCfg server, PermId reviewId, PermId commentId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.publishComment(reviewId, commentId);
-	}
-
-	public void publishAllCommentsForReview(CrucibleServerCfg server, PermId reviewId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.publishComment(reviewId, null);
-	}
-
-	public GeneralComment addGeneralCommentReply(CrucibleServerCfg server, PermId id, PermId cId, GeneralComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		GeneralCommentBean newReply = (GeneralCommentBean) session.addGeneralCommentReply(id, cId, comment);
-		fixUserName(server, newReply);
-		return newReply;
-	}
-
-	public VersionedComment addVersionedCommentReply(CrucibleServerCfg server, PermId id, PermId cId, VersionedComment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		VersionedCommentBean newReply = (VersionedCommentBean) session.addVersionedCommentReply(id, cId, comment);
-		fixUserName(server, newReply);
-		return newReply;
-	}
-
-//	public void updateReply(CrucibleServerCfg server, PermId id, PermId cId, PermId rId, GeneralComment comment)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		session.updateReply(id, cId, rId, comment);
-//	}
-
-	public void removeComment(CrucibleServerCfg server, PermId id, Comment comment)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		session.removeComment(id, comment);
-	}
-
-	public List<User> getUsers(CrucibleServerCfg server) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getUsers();
-	}
-
-	/**
-	 * Retrieves list of projects defined on Crucible server
-	 *
-	 * @param server
-	 * @return
-	 * @throws RemoteApiException
-	 * @throws ServerPasswordNotProvidedException
-	 *
-	 */
-	public List<Project> getProjects(CrucibleServerCfg server) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getProjects();
-	}
-
-
-	/**
-	 * Retrieves list of repositories defined on Crucible server
-	 *
-	 * @param server
-	 * @return
-	 * @throws RemoteApiException
-	 * @throws com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException
-	 *
-	 */
-	public List<Repository> getRepositories(CrucibleServerCfg server)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getRepositories();
-	}
-
-	public SvnRepository getRepository(CrucibleServerCfg server, String repoName)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getRepository(repoName);
-	}
-
-	public List<CustomFieldDef> getMetrics(CrucibleServerCfg server, int version)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getMetrics(version);
-	}
-
-	/**
-	 * @param server server object with Url, Login and Password to connect to
-	 * @return List of reviews (empty list in case there is no review)
-	 */
-	public List<Review> getAllReviews(CrucibleServerCfg server) throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getAllReviews(true);
-	}
-
-	public List<Review> getReviewsForFilter(CrucibleServerCfg server, PredefinedFilter filter)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getReviewsForFilter(filter, true);
-	}
-
-	public List<Review> getReviewsForCustomFilter(CrucibleServerCfg server, CustomFilter filter)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getReviewsForCustomFilter(filter, true);
-	}
-
-	public Review getReview(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getReview(permId, true);
-	}
-
-	public List<Reviewer> getReviewers(CrucibleServerCfg server, PermId permId)
-			throws RemoteApiException, ServerPasswordNotProvidedException {
-		CrucibleSession session = getSession(server);
-		return session.getReviewers(permId);
-	}
-
-//	public List<Review> getAllReviewsForFile(CrucibleServerCfg server, String repoName, String path)
-//			throws RemoteApiException, ServerPasswordNotProvidedException {
-//		CrucibleSession session = getSession(server);
-//		return session.getAllReviewsForFile(repoName, path, true);
-//	}
-
-}
+/**
+ * Copyright (C) 2008 Atlassian
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.atlassian.theplugin.commons.crucible;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import com.atlassian.theplugin.commons.ServerType;
+import com.atlassian.theplugin.commons.cfg.CrucibleServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerId;
+import com.atlassian.theplugin.commons.crucible.api.CrucibleLoginException;
+import com.atlassian.theplugin.commons.crucible.api.CrucibleSession;
+import com.atlassian.theplugin.commons.crucible.api.model.Comment;
+import com.atlassian.theplugin.commons.crucible.api.model.CommentBean;
+import com.atlassian.theplugin.commons.crucible.api.model.CrucibleFileInfo;
+import com.atlassian.theplugin.commons.crucible.api.model.CrucibleUserCache;
+import com.atlassian.theplugin.commons.crucible.api.model.CrucibleUserCacheImpl;
+import com.atlassian.theplugin.commons.crucible.api.model.CustomFieldDef;
+import com.atlassian.theplugin.commons.crucible.api.model.CustomFilter;
+import com.atlassian.theplugin.commons.crucible.api.model.GeneralComment;
+import com.atlassian.theplugin.commons.crucible.api.model.GeneralCommentBean;
+import com.atlassian.theplugin.commons.crucible.api.model.PermId;
+import com.atlassian.theplugin.commons.crucible.api.model.PredefinedFilter;
+import com.atlassian.theplugin.commons.crucible.api.model.Project;
+import com.atlassian.theplugin.commons.crucible.api.model.Repository;
+import com.atlassian.theplugin.commons.crucible.api.model.Review;
+import com.atlassian.theplugin.commons.crucible.api.model.Reviewer;
+import com.atlassian.theplugin.commons.crucible.api.model.SvnRepository;
+import com.atlassian.theplugin.commons.crucible.api.model.User;
+import com.atlassian.theplugin.commons.crucible.api.model.VersionedComment;
+import com.atlassian.theplugin.commons.crucible.api.model.VersionedCommentBean;
+import com.atlassian.theplugin.commons.crucible.api.rest.CrucibleSessionImpl;
+import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
+
+public final class CrucibleServerFacadeImpl implements CrucibleServerFacade {
+	private Map<String, CrucibleSession> sessions = new HashMap<String, CrucibleSession>();
+
+	private static CrucibleServerFacadeImpl instance;
+	private CrucibleUserCache userCache;
+	private HttpSessionCallback callback;
+	
+	private CrucibleServerFacadeImpl(CrucibleUserCache userCache) {
+		this.userCache = userCache;
+		this.callback = new HttpSessionCallbackImpl();
+	}
+
+	public static synchronized CrucibleServerFacade getInstance() {
+		if (instance == null) {
+			instance = new CrucibleServerFacadeImpl(CrucibleUserCacheImpl.getInstance());
+		}
+		return instance;
+	}
+
+	public void setUserCache(CrucibleUserCache newCache) {
+		userCache = newCache;
+	}
+
+	public ServerType getServerType() {
+		return ServerType.CRUCIBLE_SERVER;
+	}
+
+	private synchronized CrucibleSession getSession(CrucibleServerCfg server)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		String key = server.getUrl() + server.getUsername() + server.getPassword();
+		CrucibleSession session = sessions.get(key);
+		if (session == null) {
+			try {
+				session = new CrucibleSessionImpl(server, callback);
+				sessions.put(key, session);
+			} catch (RemoteApiException e) {
+				if (server.getPassword().length() > 0) {
+                	throw e;
+            	} else {
+                	throw new ServerPasswordNotProvidedException();
+            	}
+			}
+		}
+		if (!session.isLoggedIn()) {
+			session.login(server.getUsername(), server.getPassword());
+		}
+		return session;
+	}
+
+	private <T extends CommentBean> void fixUserName(CrucibleServerCfg server, T comment) {
+		User u = comment.getAuthor();
+		if (u.getDisplayName() == null || u.getDisplayName().length() == 0) {
+			User newU = userCache.getUser(server, u.getUserName(), true);
+			if (newU != null) {
+				comment.setAuthor(newU);
+			}
+		}
+	}
+
+	/**
+     * For testing Only
+     * @see com.atlassian.theplugin.commons.remoteapi.ProductServerFacade#testServerConnection(java.lang.String, java.lang.String, java.lang.String)
+     */
+    public void testServerConnection(String url, String userName, String password) throws RemoteApiException {
+    	CrucibleServerCfg serverCfg = new CrucibleServerCfg(url, new ServerId());
+    	serverCfg.setUrl(url);
+    	serverCfg.setUsername(userName);
+    	serverCfg.setPassword(password);
+    	testServerConnection(serverCfg);
+    }
+	
+	/**
+	 * @param serverCfg The configuration for the server that we want to test the connectio for
+	 *      
+	 * @throws com.atlassian.theplugin.commons.crucible.api.CrucibleException
+	 *
+	 */
+	public void testServerConnection(ServerCfg serverCfg) throws RemoteApiException {
+		assert(serverCfg instanceof CrucibleServerCfg);
+		CrucibleSession session = null;
+		session = new CrucibleSessionImpl(serverCfg, callback);
+		session.login(serverCfg.getUsername(), serverCfg.getPassword());
+		try {
+			session.getServerVersion();
+		} catch (RemoteApiException e) {
+
+			if (e.getCause().getMessage().startsWith("HTTP 500")) {
+				throw new CrucibleLoginException(
+						"Atlassian IntelliJ Connector detected a Crucible version older\n"
+						+ "than 1.6. Unfortunately, the plugin will not\n"
+						+ "work with this version of Crucible");
+			}
+		}
+
+
+		session.logout();
+	}
+
+//	public CrucibleVersionInfo getServerVersion(CrucibleServerCfg server)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.getServerVersion();
+//	}
+
+	/**
+	 * Creates new review in Crucible
+	 *
+	 * @param server
+	 * @param review data for new review to create (some fields have to be set e.g. projectKey)
+	 * @return created revew date
+	 * @throws com.atlassian.theplugin.commons.crucible.api.CrucibleException
+	 *          in case of createReview error or CrucibleLoginException in case of login error
+	 */
+	public Review createReview(CrucibleServerCfg server, Review review)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.createReview(review);
+	}
+
+	public Review createReviewFromRevision(
+			CrucibleServerCfg server,
+			Review review,
+			List<String> revisions) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		Review newReview = null;
+		if (!revisions.isEmpty()) {
+			newReview = session.createReviewFromRevision(review, revisions);
+		}
+		return newReview;
+	}
+
+//	public List<Action> getAvailableActions(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.getAvailableActions(permId);
+//	}
+
+//	public List<Action> getAvailableTransitions(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.getAvailableTransitions(permId);
+//	}
+
+	public Review addRevisionsToReview(
+			CrucibleServerCfg server,
+			PermId permId,
+			String repository,
+			List<String> revisions) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		Review review = null;
+		if (!revisions.isEmpty()) {
+			review = session.addRevisionsToReview(permId, repository, revisions);
+		}
+		return review;
+	}
+
+	public Review addPatchToReview(
+			CrucibleServerCfg server,
+			PermId permId,
+			String repository,
+			String patch) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		Review review = session.addPatchToReview(permId, repository, patch);
+		return review;
+	}
+
+//	public CrucibleFileInfo addItemToReview(CrucibleServerCfg server, Review review, NewReviewItem newItem)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.addItemToReview(review, newItem);
+//	}
+
+
+	public void addReviewers(
+			CrucibleServerCfg server,
+			PermId permId,
+			Set<String> userNames) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.addReviewers(permId, userNames);
+	}
+
+	public void removeReviewer(
+			CrucibleServerCfg server,
+			PermId permId,
+			String userName) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.removeReviewer(permId, userName);
+	}
+
+	public Review approveReview(
+			CrucibleServerCfg server,
+			PermId permId) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.approveReview(permId);
+	}
+
+	public Review submitReview(
+			CrucibleServerCfg server,
+			PermId permId) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.submitReview(permId);
+	}
+
+	public Review summarizeReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.summarizeReview(permId);
+	}
+
+	public Review abandonReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.abandonReview(permId);
+	}
+
+	public Review closeReview(CrucibleServerCfg server, PermId permId, String summary)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.closeReview(permId, summary);
+	}
+
+	public Review recoverReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.recoverReview(permId);
+	}
+
+	public Review reopenReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.reopenReview(permId);
+	}
+
+//	public Review rejectReview(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.rejectReview(permId);
+//	}
+
+	public void completeReview(CrucibleServerCfg server, PermId permId, boolean complete)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.completeReview(permId, complete);
+	}
+
+	/**
+	 * Creates new review in Crucible
+	 *
+	 * @param server
+	 * @param review data for new review to create (some fields have to be set e.g. projectKey)
+	 * @param patch  patch to assign with the review
+	 * @return created revew date
+	 * @throws com.atlassian.theplugin.commons.crucible.api.CrucibleException
+	 *          in case of createReview error or CrucibleLoginException in case of login error
+	 */
+	public Review createReviewFromPatch(CrucibleServerCfg server, Review review, String patch)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.createReviewFromPatch(review, patch);
+	}
+
+	public List<CrucibleFileInfo> getFiles(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getFiles(permId);
+	}
+
+//	public List<Comment> getComments(CrucibleServerCfg server, PermId permId)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.getComments(permId);
+//	}
+
+	public List<GeneralComment> getGeneralComments(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getGeneralComments(permId);
+	}
+
+	public List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getAllVersionedComments(permId);
+	}
+
+	public List<VersionedComment> getVersionedComments(CrucibleServerCfg server, PermId permId, PermId reviewItemId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getVersionedComments(permId, reviewItemId);
+	}
+
+	public List<GeneralComment> getReplies(CrucibleServerCfg server, PermId permId, PermId commentId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getReplies(permId, commentId);
+	}
+
+	public GeneralComment addGeneralComment(CrucibleServerCfg server, PermId permId, GeneralComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		GeneralCommentBean newComment = (GeneralCommentBean) session.addGeneralComment(permId, comment);
+		fixUserName(server, newComment);
+		return newComment;
+	}
+
+	public VersionedComment addVersionedComment(CrucibleServerCfg server, PermId permId, PermId riId, VersionedComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		VersionedCommentBean newComment = (VersionedCommentBean) session.addVersionedComment(permId, riId, comment);
+		fixUserName(server, newComment);
+		return newComment;
+	}
+
+	public void updateComment(CrucibleServerCfg server, PermId id, Comment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.updateComment(id, comment);
+	}
+
+	public void publishComment(CrucibleServerCfg server, PermId reviewId, PermId commentId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.publishComment(reviewId, commentId);
+	}
+
+	public void publishAllCommentsForReview(CrucibleServerCfg server, PermId reviewId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.publishComment(reviewId, null);
+	}
+
+	public GeneralComment addGeneralCommentReply(CrucibleServerCfg server, PermId id, PermId cId, GeneralComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		GeneralCommentBean newReply = (GeneralCommentBean) session.addGeneralCommentReply(id, cId, comment);
+		fixUserName(server, newReply);
+		return newReply;
+	}
+
+	public VersionedComment addVersionedCommentReply(CrucibleServerCfg server, PermId id, PermId cId, VersionedComment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		VersionedCommentBean newReply = (VersionedCommentBean) session.addVersionedCommentReply(id, cId, comment);
+		fixUserName(server, newReply);
+		return newReply;
+	}
+
+//	public void updateReply(CrucibleServerCfg server, PermId id, PermId cId, PermId rId, GeneralComment comment)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		session.updateReply(id, cId, rId, comment);
+//	}
+
+	public void removeComment(CrucibleServerCfg server, PermId id, Comment comment)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		session.removeComment(id, comment);
+	}
+
+	public List<User> getUsers(CrucibleServerCfg server) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getUsers();
+	}
+
+	/**
+	 * Retrieves list of projects defined on Crucible server
+	 *
+	 * @param server
+	 * @return
+	 * @throws RemoteApiException
+	 * @throws ServerPasswordNotProvidedException
+	 *
+	 */
+	public List<Project> getProjects(CrucibleServerCfg server) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getProjects();
+	}
+
+
+	/**
+	 * Retrieves list of repositories defined on Crucible server
+	 *
+	 * @param server
+	 * @return
+	 * @throws RemoteApiException
+	 * @throws com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException
+	 *
+	 */
+	public List<Repository> getRepositories(CrucibleServerCfg server)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getRepositories();
+	}
+
+	public SvnRepository getRepository(CrucibleServerCfg server, String repoName)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getRepository(repoName);
+	}
+
+	public List<CustomFieldDef> getMetrics(CrucibleServerCfg server, int version)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getMetrics(version);
+	}
+
+	/**
+	 * @param server server object with Url, Login and Password to connect to
+	 * @return List of reviews (empty list in case there is no review)
+	 */
+	public List<Review> getAllReviews(CrucibleServerCfg server) throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getAllReviews(true);
+	}
+
+	public List<Review> getReviewsForFilter(CrucibleServerCfg server, PredefinedFilter filter)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getReviewsForFilter(filter, true);
+	}
+
+	public List<Review> getReviewsForCustomFilter(CrucibleServerCfg server, CustomFilter filter)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getReviewsForCustomFilter(filter, true);
+	}
+
+	public Review getReview(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getReview(permId, true);
+	}
+
+	public List<Reviewer> getReviewers(CrucibleServerCfg server, PermId permId)
+			throws RemoteApiException, ServerPasswordNotProvidedException {
+		CrucibleSession session = getSession(server);
+		return session.getReviewers(permId);
+	}
+
+//	public List<Review> getAllReviewsForFile(CrucibleServerCfg server, String repoName, String path)
+//			throws RemoteApiException, ServerPasswordNotProvidedException {
+//		CrucibleSession session = getSession(server);
+//		return session.getAllReviewsForFile(repoName, path, true);
+//	}
+
+	public void setCallback(HttpSessionCallback callback) {
+		this.callback = callback;
+	}
+}
Index: src/main/java/com/atlassian/theplugin/commons/crucible/api/rest/CrucibleSessionImpl.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/crucible/api/rest/CrucibleSessionImpl.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/crucible/api/rest/CrucibleSessionImpl.java	(working copy)
@@ -1,1417 +1,1468 @@
-/**
- * Copyright (C) 2008 Atlassian
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.atlassian.theplugin.commons.crucible.api.rest;
-
-import com.atlassian.theplugin.commons.VersionedVirtualFile;
-import com.atlassian.theplugin.commons.crucible.ValueNotYetInitialized;
-import com.atlassian.theplugin.commons.crucible.api.CrucibleSession;
-import com.atlassian.theplugin.commons.crucible.api.model.*;
-import com.atlassian.theplugin.commons.remoteapi.*;
-import com.atlassian.theplugin.commons.remoteapi.rest.AbstractHttpSession;
-import org.apache.commons.codec.binary.Base64;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpMethod;
-import org.jdom.Document;
-import org.jdom.Element;
-import org.jdom.JDOMException;
-import org.jdom.xpath.XPath;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.MalformedURLException;
-import java.net.URLEncoder;
-import java.net.UnknownHostException;
-import java.util.*;
-
-/**
- * Communication stub for Crucible REST API.
- */
-public class CrucibleSessionImpl extends AbstractHttpSession implements CrucibleSession {
-	private static final String AUTH_SERVICE = "/rest-service/auth-v1";
-	private static final String REVIEW_SERVICE = "/rest-service/reviews-v1";
-	private static final String PROJECTS_SERVICE = "/rest-service/projects-v1";
-	private static final String REPOSITORIES_SERVICE = "/rest-service/repositories-v1";
-	private static final String USER_SERVICE = "/rest-service/users-v1";
-
-	private static final String LOGIN = "/login";
-	private static final String REVIEWS_IN_STATES = "?state=";
-	private static final String FILTERED_REVIEWS = "/filter";
-	private static final String SEARCH_REVIEWS = "/search";
-	private static final String SEARCH_REVIEWS_QUERY = "?path=";
-	private static final String DETAIL_REVIEW_INFO = "/details";
-	private static final String ACTIONS = "/actions";
-	private static final String TRANSITIONS = "/transitions";
-	private static final String REVIEWERS = "/reviewers";
-	private static final String REVIEW_ITEMS = "/reviewitems";
-	private static final String METRICS = "/metrics";
-	private static final String VERSION = "/versionInfo";
-
-	private static final String COMMENTS = "/comments";
-	private static final String GENERAL_COMMENTS = "/comments/general";
-	private static final String VERSIONED_COMMENTS = "/comments/versioned";
-	private static final String REPLIES = "/replies";
-
-	private static final String APPROVE_ACTION = "action:approveReview";
-	private static final String SUBMIT_ACTION = "action:submitReview";
-	private static final String SUMMARIZE_ACTION = "action:summarizeReview";
-	private static final String ABANDON_ACTION = "action:abandonReview";
-	private static final String CLOSE_ACTION = "action:closeReview";
-	private static final String RECOVER_ACTION = "action:recoverReview";
-	private static final String REOPEN_ACTION = "action:reopenReview";
-	private static final String REJECT_ACTION = "action:rejectReview";
-	private static final String TRANSITION_ACTION = "/transition?action=";
-
-	private static final String PUBLISH_COMMENTS = "/publish";
-	private static final String COMPLETE_ACTION = "/complete";
-	private static final String UNCOMPLETE_ACTION = "/uncomplete";
-
-	private static final String ADD_CHANGESET = "/addChangeset";
-	private static final String ADD_PATCH = "/addPatch";
-//	private static final String ADD_ITEM = "/addItem";
-
-	private String authToken = null;
-
-	private Map<String, SvnRepository> repositories = new HashMap<String, SvnRepository>();
-	private Map<String, List<CustomFieldDef>> metricsDefinitions = new HashMap<String, List<CustomFieldDef>>();
-
-
-	/**
-	 * Public constructor for CrucibleSessionImpl.
-	 *
-	 * @param url base url
-	 * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
-	 *
-	 */
-	public CrucibleSessionImpl(String url) throws RemoteApiMalformedUrlException {
-		super(url);
-	}
-
-	public void login(String username, String aPassword) throws RemoteApiLoginException {
-		if (!isLoggedIn()) {
-			String loginUrl;
-			try {
-				if (username == null || aPassword == null) {
-					throw new RemoteApiLoginException("Corrupted configuration. Username or Password null");
-				}
-				loginUrl = baseUrl + AUTH_SERVICE + LOGIN + "?userName=" + URLEncoder.encode(username, "UTF-8")
-						+ "&password=" + URLEncoder.encode(aPassword, "UTF-8");
-			} catch (UnsupportedEncodingException e) {
-				///CLOVER:OFF
-				throw new RuntimeException("URLEncoding problem: " + e.getMessage());
-				///CLOVER:ON
-			}
-
-			try {
-				Document doc = retrieveGetResponse(loginUrl);
-				String exception = getExceptionMessages(doc);
-				if (null != exception) {
-					throw new RemoteApiLoginFailedException(exception);
-				}
-				XPath xpath = XPath.newInstance("/loginResult/token");
-				List<?> elements = xpath.selectNodes(doc);
-				if (elements == null) {
-					throw new RemoteApiLoginException("Server did not return any authentication token");
-				}
-				if (elements.size() != 1) {
-					throw new RemoteApiLoginException("Server returned unexpected number of authentication tokens ("
-							+ elements.size() + ")");
-				}
-				this.authToken = ((Element) elements.get(0)).getText();
-				this.userName = username;
-				this.password = aPassword;
-			} catch (MalformedURLException e) {
-				throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
-			} catch (UnknownHostException e) {
-				throw new RemoteApiLoginException("Unknown host: " + e.getMessage(), e);
-			} catch (IOException e) {
-				throw new RemoteApiLoginException(baseUrl + ":" + e.getMessage(), e);
-			} catch (JDOMException e) {
-				throw new RemoteApiLoginException("Server:" + baseUrl + " returned malformed response", e);
-			} catch (RemoteApiSessionExpiredException e) {
-				// Crucible does not return this exception
-			} catch (IllegalArgumentException e) {
-				throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
-			}
-		}
-	}
-
-	public void logout() {
-		if (authToken != null) {
-			authToken = null;
-			userName = null;
-			password = null;
-		}
-	}
-
-	public CrucibleVersionInfo getServerVersion() throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + VERSION;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("versionInfo");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					return CrucibleRestXmlHelper.parseVersionNode(element);
-				}
-			}
-
-			throw new RemoteApiException("No version info found in server response");
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	private void updateMetricsMetadata(Review review) {
-		try {
-			getMetrics(review.getMetricsVersion());
-		} catch (RemoteApiException e) {
-			// can be swallowed - metrics metadata are useful, but not necessery
-		}
-	}
-
-	public List<Review> getReviewsInStates(List<State> states, boolean details) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		StringBuilder sb = new StringBuilder();
-		sb.append(baseUrl);
-		sb.append(REVIEW_SERVICE);
-		if (details) {
-			sb.append(DETAIL_REVIEW_INFO);
-		}
-		if (states != null && states.size() != 0) {
-			sb.append(REVIEWS_IN_STATES);
-			for (Iterator<State> stateIterator = states.iterator(); stateIterator.hasNext();) {
-				State state = stateIterator.next();
-				sb.append(state.value());
-				if (stateIterator.hasNext()) {
-					sb.append(",");
-				}
-			}
-		}
-
-		try {
-			Document doc = retrieveGetResponse(sb.toString());
-
-			XPath xpath;
-			if (details) {
-				xpath = XPath.newInstance("/detailedReviews/detailedReviewData");
-			} else {
-				xpath = XPath.newInstance("/reviews/reviewData");
-			}
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Review> reviews = new ArrayList<Review>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					if (details) {
-						reviews.add(prepareDetailReview(element));
-					} else {
-						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
-					}
-				}
-			}
-			for (Review review : reviews) {
-				updateMetricsMetadata(review);
-			}
-			return reviews;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Review> getAllReviews(boolean details) throws RemoteApiException {
-		return getReviewsInStates(null, details);
-	}
-
-	public List<Review> getReviewsForFilter(PredefinedFilter filter, boolean details) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		try {
-			String url = baseUrl
-					+ REVIEW_SERVICE
-					+ FILTERED_REVIEWS
-					+ "/" + filter.getFilterUrl();
-			if (details) {
-				url += DETAIL_REVIEW_INFO;
-			}
-			Document doc = retrieveGetResponse(url);
-
-			XPath xpath;
-			if (details) {
-				xpath = XPath.newInstance("/detailedReviews/detailedReviewData");
-			} else {
-				xpath = XPath.newInstance("/reviews/reviewData");
-			}
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Review> reviews = new ArrayList<Review>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					if (details) {
-						reviews.add(prepareDetailReview(element));
-					} else {
-						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
-					}
-				}
-			}
-			for (Review review : reviews) {
-				updateMetricsMetadata(review);
-			}
-			return reviews;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Review> getReviewsForCustomFilter(CustomFilter filter, boolean details) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-		Document request = CrucibleRestXmlHelper.prepareCustomFilter(filter);
-
-		try {
-			String url = baseUrl + REVIEW_SERVICE + FILTERED_REVIEWS;
-			if (details) {
-				url += DETAIL_REVIEW_INFO;
-			}
-
-			Document doc = retrievePostResponse(url, request);
-			XPath xpath;
-			if (details) {
-				xpath = XPath.newInstance("/detailedReviews/detailReviewData");
-			} else {
-				xpath = XPath.newInstance("/reviews/reviewData");
-			}
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Review> reviews = new ArrayList<Review>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					if (details) {
-						reviews.add(prepareDetailReview(element));
-					} else {
-						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
-					}
-				}
-			}
-			for (Review review : reviews) {
-				updateMetricsMetadata(review);
-			}
-			return reviews;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Review> getAllReviewsForFile(String repoName, String path, boolean details) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		try {
-			String url = baseUrl
-					+ REVIEW_SERVICE
-					+ SEARCH_REVIEWS
-					+ "/"
-					+ URLEncoder.encode(repoName, "UTF-8");
-			if (details) {
-				url += DETAIL_REVIEW_INFO;
-			}
-			url = url
-					+ SEARCH_REVIEWS_QUERY
-					+ URLEncoder.encode(path, "UTF-8");
-			Document doc = retrieveGetResponse(url);
-
-			XPath xpath;
-			if (details) {
-				xpath = XPath.newInstance("/detailedReviews/detailReviewData");
-			} else {
-				xpath = XPath.newInstance("/reviews/reviewData");
-			}
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Review> reviews = new ArrayList<Review>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					if (details) {
-						reviews.add(prepareDetailReview(element));
-					} else {
-						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
-					}
-				}
-			}
-			for (Review review : reviews) {
-				updateMetricsMetadata(review);
-			}
-			return reviews;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public Review getReview(PermId permId, boolean details) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		try {
-			String url = baseUrl
-					+ REVIEW_SERVICE
-					+ "/"
-					+ permId.getId();
-			if (details) {
-				url += DETAIL_REVIEW_INFO;
-			}
-			Document doc = retrieveGetResponse(url);
-
-			XPath xpath;
-			if (details) {
-				xpath = XPath.newInstance("/detailedReviewData");
-			} else {
-				xpath = XPath.newInstance("reviewData");
-			}
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					if (details) {
-						return prepareDetailReview(element);
-					} else {
-						return CrucibleRestXmlHelper.parseReviewNode(baseUrl, element);
-					}
-				}
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void fillRepositoryData(CrucibleFileInfo fileInfo) throws RemoteApiException {
-		String repoName = fileInfo.getRepositoryName();
-		if (repoName == null) {
-			// oh well, it can be null - fileInfos are mostly empty now
-			return;
-		}
-
-		String[] repoNameTokens = repoName.split(":");
-
-		if (!repositories.containsKey(repoName)) {
-			SvnRepository repository = getRepository(repoNameTokens.length > 1 ? repoNameTokens[1] : repoNameTokens[0]);
-			repositories.put(repoName, repository);
-		}
-		SvnRepository repository = repositories.get(repoName);
-		if (repository != null) {
-			String repoPath = repository.getUrl() + "/" + repository.getPath() + "/";
-			VersionedVirtualFile oldDescriptor = fileInfo.getOldFileDescriptor();
-			if (!oldDescriptor.getUrl().equals("")) {
-				oldDescriptor.setRepoUrl(repoPath);
-			}
-			VersionedVirtualFile newDescriptor = fileInfo.getFileDescriptor();
-			if (!newDescriptor.getUrl().equals("")) {
-				newDescriptor.setRepoUrl(repoPath);
-			}
-		}
-	}
-
-	private Review prepareDetailReview(Element element) throws RemoteApiException {
-		ReviewBean review = CrucibleRestXmlHelper.parseDetailedReviewNode(baseUrl, element);
-
-//		for (CrucibleFileInfo fileInfo : CrucibleFileInfoManager.getInstance().getFiles(review)) {
-//			fillRepositoryData(fileInfo);
-//		}
-		try {
-			for (CrucibleFileInfo fileInfo : review.getFiles()) {
-				fillRepositoryData(fileInfo);
-			}
-		} catch (ValueNotYetInitialized valueNotYetInitialized) {
-			// cannot fill
-		}
-		return review;
-	}
-
-	public List<Reviewer> getReviewers(PermId permId) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + REVIEWERS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("/reviewers/reviewer");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Reviewer> reviewers = new ArrayList<Reviewer>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					reviewers.add(CrucibleRestXmlHelper.parseReviewerNode(element));
-				}
-			}
-			return reviewers;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<User> getUsers() throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + USER_SERVICE;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("/users/userData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<User> users = new ArrayList<User>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					users.add(CrucibleRestXmlHelper.parseUserNode(element));
-				}
-			}
-			return users;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Project> getProjects() throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + PROJECTS_SERVICE;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("/projects/projectData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Project> projects = new ArrayList<Project>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					projects.add(CrucibleRestXmlHelper.parseProjectNode(element));
-				}
-			}
-			return projects;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Repository> getRepositories() throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REPOSITORIES_SERVICE;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("/repositories/repoData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Repository> myRepositories = new ArrayList<Repository>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					myRepositories.add(CrucibleRestXmlHelper.parseRepositoryNode(element));
-				}
-			}
-			return myRepositories;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public SvnRepository getRepository(String repoName) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		List<Repository> myRepositories = getRepositories();
-		for (Repository repository : myRepositories) {
-			if (repository.getName().equals(repoName)) {
-				if (repository.getType().equals("svn")) {
-					String requestUrl = baseUrl + REPOSITORIES_SERVICE + "/" + repoName + "/svn";
-					try {
-						Document doc = retrieveGetResponse(requestUrl);
-						XPath xpath = XPath.newInstance("/svnRepositoryData");
-						@SuppressWarnings("unchecked")
-						List<Element> elements = xpath.selectNodes(doc);
-						if (elements != null && !elements.isEmpty()) {
-							for (Element element : elements) {
-								return CrucibleRestXmlHelper.parseSvnRepositoryNode(element);
-							}
-						}
-					} catch (IOException e) {
-						throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-					} catch (JDOMException e) {
-						throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-					}
-				}
-			}
-		}
-		return null;
-	}
-
-	public List<CrucibleFileInfo> getFiles(PermId id) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + REVIEW_ITEMS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("reviewItems/reviewItem");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<CrucibleFileInfo> reviewItems = new ArrayList<CrucibleFileInfo>();
-
-			Review changeSet = new ReviewBean(baseUrl);
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					CrucibleFileInfo fileInfo = CrucibleRestXmlHelper.parseReviewItemNode(changeSet, element);
-					fillRepositoryData(fileInfo);
-					reviewItems.add(fileInfo);
-				}
-			}
-			return reviewItems;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-//	public CrucibleFileInfo addItemToReview(Review review, NewReviewItem item) throws RemoteApiException {
-//		if (!isLoggedIn()) {
-//			throw new IllegalStateException("Calling method without calling login() first");
-//		}
-//
-//		Document request = CrucibleRestXmlHelper.prepareAddItemNode(item);
-//		try {
-//			String url = baseUrl + REVIEW_SERVICE + "/" + review.getPermId().getId() + REVIEW_ITEMS;
-//			Document doc = retrievePostResponse(url, request);
-//			XPath xpath = XPath.newInstance("/reviewItem");
-//			@SuppressWarnings("unchecked")
-//			List<Element> elements = xpath.selectNodes(doc);
-//
-//			if (elements != null && !elements.isEmpty()) {
-//				CrucibleFileInfo fileInfo = CrucibleRestXmlHelper.parseReviewItemNode(review, elements.iterator().next());
-//				fillRepositoryData(fileInfo);
-//				CrucibleFileInfoManager.getInstance().getFiles(review).add(fileInfo);
-//				return fileInfo;
-//			}
-//			return null;
-//		} catch (IOException e) {
-//			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-//		} catch (JDOMException e) {
-//			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-//		}
-//	}
-
-	public List<GeneralComment> getGeneralComments(PermId id) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + GENERAL_COMMENTS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("comments/generalCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<GeneralComment> comments = new ArrayList<GeneralComment>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					comments.add(CrucibleRestXmlHelper.parseGeneralCommentNode(element));
-				}
-			}
-			return comments;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<VersionedComment> getAllVersionedComments(PermId id) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + VERSIONED_COMMENTS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("comments/versionedLineCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<VersionedComment> comments = new ArrayList<VersionedComment>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					comments.add(CrucibleRestXmlHelper.parseVersionedCommentNode(element));
-				}
-			}
-			return comments;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<VersionedComment> getVersionedComments(PermId id, PermId reviewItemId) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + REVIEW_ITEMS + "/" + reviewItemId.getId() + COMMENTS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("comments/versionedLineCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<VersionedComment> comments = new ArrayList<VersionedComment>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					comments.add(CrucibleRestXmlHelper.parseVersionedCommentNode(element));
-				}
-			}
-			return comments;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<GeneralComment> getReplies(PermId id, PermId commentId) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + commentId.getId() + REPLIES;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("comments/generalCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<GeneralComment> comments = new ArrayList<GeneralComment>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					comments.add(CrucibleRestXmlHelper.parseGeneralCommentNode(element));
-				}
-			}
-			return comments;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-//	public List<Comment> getComments(PermId id) throws RemoteApiException {
-//		if (!isLoggedIn()) {
-//			throw new IllegalStateException("Calling method without calling login() first");
-//		}
-//
-//		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS;
-//		try {
-//			Document doc = retrieveGetResponse(requestUrl);
-//
-//			XPath xpath = XPath.newInstance("comments/generalCommentData");
-//			@SuppressWarnings("unchecked")
-//			List<Element> elements = xpath.selectNodes(doc);
-//			List<Comment> comments = new ArrayList<Comment>();
-//
-//			if (elements != null && !elements.isEmpty()) {
-//				int i = 1;
-//				for (Element element : elements) {
-//					GeneralCommentBean comment = CrucibleRestXmlHelper.parseGeneralCommentNode(element);
-//					XPath repliesPath = XPath.newInstance("comments/generalCommentData[" + (i++)
-//							+ "]/replies/generalCommentData");
-//					@SuppressWarnings("unchecked")
-//					final List<Element> replies = repliesPath.selectNodes(doc);
-//					if (replies != null && !replies.isEmpty()) {
-//						for (Element reply : replies) {
-//							comment.addReply(CrucibleRestXmlHelper.parseGeneralCommentNode(reply));
-//						}
-//					}
-//					comments.add(comment);
-//				}
-//			}
-//
-//			xpath = XPath.newInstance("comments/versionedLineCommentData");
-//			@SuppressWarnings("unchecked")
-//			List<Element> vElements = xpath.selectNodes(doc);
-//
-//			if (vElements != null && !vElements.isEmpty()) {
-//				int i = 1;
-//				for (Element element : vElements) {
-//					VersionedCommentBean comment = CrucibleRestXmlHelper.parseVersionedCommentNode(element);
-//					XPath repliesPath = XPath.newInstance("comments/versionedLineCommentData[" + (i++)
-//							+ "]/replies/generalCommentData");
-//					@SuppressWarnings("unchecked")
-//					final List<Element> replies = repliesPath.selectNodes(doc);
-//					if (replies != null && !replies.isEmpty()) {
-//						for (Element reply : replies) {
-//							comment.addReply(CrucibleRestXmlHelper.parseVersionedCommentNode(reply));
-//						}
-//					}
-//					comments.add(comment);
-//				}
-//			}
-//
-//			return comments;
-//		} catch (IOException e) {
-//			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-//		} catch (JDOMException e) {
-//			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-//		}
-//	}
-
-	public GeneralComment addGeneralComment(PermId id, GeneralComment comment) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS;
-		try {
-			Document doc = retrievePostResponse(requestUrl, request);
-
-			XPath xpath = XPath.newInstance("generalCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					return CrucibleRestXmlHelper.parseGeneralCommentNode(element);
-				}
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void removeComment(PermId id, Comment comment) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + comment.getPermId().getId();
-		try {
-			retrieveDeleteResponse(requestUrl, false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void updateComment(PermId id, Comment comment) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + comment.getPermId().getId();
-
-		try {
-			retrievePostResponse(requestUrl, request, false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void publishComment(PermId reviewId, PermId commentId) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + reviewId.getId() + PUBLISH_COMMENTS;
-		if (commentId != null) {
-			requestUrl += "/" + commentId.getId();
-		}
-
-		try {
-			retrievePostResponse(requestUrl, "", false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		} catch (RemoteApiSessionExpiredException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		}
-	}
-
-	public VersionedComment addVersionedComment(PermId id, PermId riId, VersionedComment comment) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareVersionedComment(riId, comment);
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + REVIEW_ITEMS + "/"
-				+ riId.getId() + COMMENTS;
-		try {
-			Document doc = retrievePostResponse(requestUrl, request);
-			XPath xpath = XPath.newInstance("versionedLineCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					return CrucibleRestXmlHelper.parseVersionedCommentNode(element);
-				}
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public GeneralComment addGeneralCommentReply(PermId id, PermId cId, GeneralComment comment) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + cId.getId() + REPLIES;
-
-		try {
-			Document doc = retrievePostResponse(requestUrl, request);
-
-			XPath xpath = XPath.newInstance("generalCommentData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					GeneralCommentBean reply = CrucibleRestXmlHelper.parseGeneralCommentNode(element);
-					reply.setReply(true);
-					return reply;
-				}
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public VersionedComment addVersionedCommentReply(PermId id, PermId cId, VersionedComment comment)
-			throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + cId.getId() + REPLIES;
-
-		try {
-			Document doc = retrievePostResponse(requestUrl, request);
-
-			XPath xpath = XPath.newInstance("generalCommentData");  // todo lguminski we should change it to reflect model
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					VersionedCommentBean reply = CrucibleRestXmlHelper.parseVersionedCommentNode(element);
-					reply.setReply(true);
-					return reply;
-				}
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-
-	}
-
-	public void updateReply(PermId id, PermId cId, PermId rId, GeneralComment comment) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/"
-				+ cId.getId() + REPLIES + "/" + rId.getId();
-
-		try {
-			retrievePostResponse(requestUrl, request, false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public Review createReview(Review review) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-		return createReviewFromPatch(review, null);
-	}
-
-	public Review createReviewFromPatch(Review review, String patch) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareCreateReviewNode(review, patch);
-		try {
-			Document doc = retrievePostResponse(baseUrl + REVIEW_SERVICE, request);
-
-			XPath xpath = XPath.newInstance("/reviewData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public Review createReviewFromRevision(Review review, List<String> revisions) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareCreateReviewNode(review, revisions);
-
-//		XmlUtil.printXml(request);
-
-		try {
-			Document doc = retrievePostResponse(baseUrl + REVIEW_SERVICE, request);
-			XPath xpath = XPath.newInstance("/reviewData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Action> getAvailableActions(PermId permId) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + ACTIONS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("/actions/actionData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Action> actions = new ArrayList<Action>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					actions.add(CrucibleRestXmlHelper.parseActionNode(element));
-				}
-			}
-			return actions;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<Action> getAvailableTransitions(PermId permId) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + TRANSITIONS;
-		try {
-			Document doc = retrieveGetResponse(requestUrl);
-
-			XPath xpath = XPath.newInstance("/transitions/actionData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			List<Action> transitions = new ArrayList<Action>();
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					transitions.add(CrucibleRestXmlHelper.parseActionNode(element));
-				}
-			}
-			return transitions;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public Review addRevisionsToReview(PermId permId, String repository, List<String> revisions) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareAddChangesetNode(repository, revisions);
-
-		try {
-			String url = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + ADD_CHANGESET;
-			Document doc = retrievePostResponse(url, request);
-
-
-			XPath xpath = XPath.newInstance("/reviewData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public Review addPatchToReview(PermId permId, String repository, String patch) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		Document request = CrucibleRestXmlHelper.prepareAddPatchNode(repository, patch);
-
-		try {
-			String url = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + ADD_PATCH;
-			Document doc = retrievePostResponse(url, request);
-
-			XPath xpath = XPath.newInstance("/reviewData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-
-			if (elements != null && !elements.isEmpty()) {
-				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
-			}
-			return null;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void addReviewers(PermId permId, Set<String> users) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + REVIEWERS;
-		String reviewers = "";
-		for (String user : users) {
-			if (reviewers.length() > 0) {
-				reviewers += ",";
-			}
-			reviewers += user;
-		}
-
-		try {
-			retrievePostResponse(requestUrl, reviewers, false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void removeReviewer(PermId permId, String username) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + REVIEWERS + "/" + username;
-		try {
-			retrieveDeleteResponse(requestUrl, false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	private Review changeReviewState(PermId permId, String action) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + TRANSITION_ACTION + action;
-		try {
-			Document doc = retrievePostResponse(requestUrl, "", true);
-
-			XPath xpath = XPath.newInstance("reviewData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			Review review = null;
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					review = CrucibleRestXmlHelper.parseReviewNode(baseUrl, element);
-				}
-			}
-			return review;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public void completeReview(PermId permId, boolean complete) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId();
-		if (complete) {
-			requestUrl += COMPLETE_ACTION;
-		} else {
-			requestUrl += UNCOMPLETE_ACTION;
-		}
-
-		try {
-			retrievePostResponse(requestUrl, "", false);
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public Review approveReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, APPROVE_ACTION);
-	}
-
-	public Review submitReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, SUBMIT_ACTION);
-	}
-
-	public Review abandonReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, ABANDON_ACTION);
-	}
-
-	public Review summarizeReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, SUMMARIZE_ACTION);
-	}
-
-	public Review recoverReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, RECOVER_ACTION);
-	}
-
-	public Review reopenReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, REOPEN_ACTION);
-	}
-
-	public Review rejectReview(PermId permId) throws RemoteApiException {
-		return changeReviewState(permId, REJECT_ACTION);
-	}
-
-	public Review closeReview(PermId permId, String summarizeMessage) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		try {
-			Document doc;
-			if (summarizeMessage != null && !"".equals(summarizeMessage)) {
-				Document request = CrucibleRestXmlHelper.prepareCloseReviewSummaryNode(summarizeMessage);
-				String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + "/close";
-				doc = retrievePostResponse(requestUrl, request);
-			} else {
-				String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + TRANSITION_ACTION + CLOSE_ACTION;
-				doc = retrievePostResponse(requestUrl, "", true);
-			}
-
-			XPath xpath = XPath.newInstance("reviewData");
-			@SuppressWarnings("unchecked")
-			List<Element> elements = xpath.selectNodes(doc);
-			Review review = null;
-
-			if (elements != null && !elements.isEmpty()) {
-				for (Element element : elements) {
-					review = CrucibleRestXmlHelper.parseReviewNode(baseUrl, element);
-				}
-			}
-			return review;
-		} catch (IOException e) {
-			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-		} catch (JDOMException e) {
-			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-		}
-	}
-
-	public List<CustomFieldDef> getMetrics(int version) throws RemoteApiException {
-		if (!isLoggedIn()) {
-			throw new IllegalStateException("Calling method without calling login() first");
-		}
-
-		String key = Integer.toString(version);
-		if (!metricsDefinitions.containsKey(key)) {
-			String requestUrl = baseUrl + REVIEW_SERVICE + METRICS + "/" + Integer.toString(version);
-			try {
-				Document doc = retrieveGetResponse(requestUrl);
-
-				XPath xpath = XPath.newInstance("metrics/metricsData");
-				@SuppressWarnings("unchecked")
-				List<Element> elements = xpath.selectNodes(doc);
-				List<CustomFieldDef> metrics = new ArrayList<CustomFieldDef>();
-
-				if (elements != null && !elements.isEmpty()) {
-					for (Element element : elements) {
-						metrics.add(CrucibleRestXmlHelper.parseMetricsNode(element));
-					}
-				}
-				metricsDefinitions.put(key, metrics);
-			} catch (IOException e) {
-				throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
-			} catch (JDOMException e) {
-				throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
-			}
-		}
-		return metricsDefinitions.get(key);
-	}
-
-	@Override
-	protected void adjustHttpHeader(HttpMethod method) {
-		method.addRequestHeader(new Header("Authorization", getAuthHeaderValue()));
-	}
-
-	@Override
-	protected void preprocessResult(Document doc) throws JDOMException, RemoteApiSessionExpiredException {
-
-	}
-
-	private String getAuthHeaderValue() {
-		return "Basic " + encode(userName + ":" + password);
-	}
-
-	private synchronized String encode(String str2encode) {
-		try {
-			Base64 base64 = new Base64();
-			byte[] bytes = base64.encode(str2encode.getBytes("UTF-8"));
-			return new String(bytes);
-		} catch (UnsupportedEncodingException e) {
-			throw new RuntimeException("UTF-8 is not supported", e);
-		}
-	}
-
-	private static String getExceptionMessages(Document doc) throws JDOMException {
-		XPath xpath = XPath.newInstance("/loginResult/error");
-		@SuppressWarnings("unchecked")
-		List<Element> elements = xpath.selectNodes(doc);
-
-		if (elements != null && elements.size() > 0) {
-			StringBuffer exceptionMsg = new StringBuffer();
-			for (Element e : elements) {
-				exceptionMsg.append(e.getText());
-				exceptionMsg.append("\n");
-			}
-			return exceptionMsg.toString();
-		} else {
-			/* no exception */
-			return null;
-		}
-	}
-
-	public boolean isLoggedIn() {
-		return authToken != null;
-	}
+/**
+ * Copyright (C) 2008 Atlassian
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.atlassian.theplugin.commons.crucible.api.rest;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
+import java.net.URLEncoder;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.codec.binary.Base64;
+import org.apache.commons.httpclient.Header;
+import org.apache.commons.httpclient.HttpMethod;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.xpath.XPath;
+
+import com.atlassian.theplugin.commons.VersionedVirtualFile;
+import com.atlassian.theplugin.commons.cfg.CrucibleServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerId;
+import com.atlassian.theplugin.commons.crucible.ValueNotYetInitialized;
+import com.atlassian.theplugin.commons.crucible.api.CrucibleSession;
+import com.atlassian.theplugin.commons.crucible.api.model.Action;
+import com.atlassian.theplugin.commons.crucible.api.model.Comment;
+import com.atlassian.theplugin.commons.crucible.api.model.CrucibleFileInfo;
+import com.atlassian.theplugin.commons.crucible.api.model.CrucibleVersionInfo;
+import com.atlassian.theplugin.commons.crucible.api.model.CustomFieldDef;
+import com.atlassian.theplugin.commons.crucible.api.model.CustomFilter;
+import com.atlassian.theplugin.commons.crucible.api.model.GeneralComment;
+import com.atlassian.theplugin.commons.crucible.api.model.GeneralCommentBean;
+import com.atlassian.theplugin.commons.crucible.api.model.PermId;
+import com.atlassian.theplugin.commons.crucible.api.model.PredefinedFilter;
+import com.atlassian.theplugin.commons.crucible.api.model.Project;
+import com.atlassian.theplugin.commons.crucible.api.model.Repository;
+import com.atlassian.theplugin.commons.crucible.api.model.Review;
+import com.atlassian.theplugin.commons.crucible.api.model.ReviewBean;
+import com.atlassian.theplugin.commons.crucible.api.model.Reviewer;
+import com.atlassian.theplugin.commons.crucible.api.model.State;
+import com.atlassian.theplugin.commons.crucible.api.model.SvnRepository;
+import com.atlassian.theplugin.commons.crucible.api.model.User;
+import com.atlassian.theplugin.commons.crucible.api.model.VersionedComment;
+import com.atlassian.theplugin.commons.crucible.api.model.VersionedCommentBean;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginFailedException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiSessionExpiredException;
+import com.atlassian.theplugin.commons.remoteapi.rest.AbstractHttpSession;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
+
+/**
+ * Communication stub for Crucible REST API.
+ */
+public class CrucibleSessionImpl extends AbstractHttpSession implements CrucibleSession {
+	private static final String AUTH_SERVICE = "/rest-service/auth-v1";
+	private static final String REVIEW_SERVICE = "/rest-service/reviews-v1";
+	private static final String PROJECTS_SERVICE = "/rest-service/projects-v1";
+	private static final String REPOSITORIES_SERVICE = "/rest-service/repositories-v1";
+	private static final String USER_SERVICE = "/rest-service/users-v1";
+
+	private static final String LOGIN = "/login";
+	private static final String REVIEWS_IN_STATES = "?state=";
+	private static final String FILTERED_REVIEWS = "/filter";
+	private static final String SEARCH_REVIEWS = "/search";
+	private static final String SEARCH_REVIEWS_QUERY = "?path=";
+	private static final String DETAIL_REVIEW_INFO = "/details";
+	private static final String ACTIONS = "/actions";
+	private static final String TRANSITIONS = "/transitions";
+	private static final String REVIEWERS = "/reviewers";
+	private static final String REVIEW_ITEMS = "/reviewitems";
+	private static final String METRICS = "/metrics";
+	private static final String VERSION = "/versionInfo";
+
+	private static final String COMMENTS = "/comments";
+	private static final String GENERAL_COMMENTS = "/comments/general";
+	private static final String VERSIONED_COMMENTS = "/comments/versioned";
+	private static final String REPLIES = "/replies";
+
+	private static final String APPROVE_ACTION = "action:approveReview";
+	private static final String SUBMIT_ACTION = "action:submitReview";
+	private static final String SUMMARIZE_ACTION = "action:summarizeReview";
+	private static final String ABANDON_ACTION = "action:abandonReview";
+	private static final String CLOSE_ACTION = "action:closeReview";
+	private static final String RECOVER_ACTION = "action:recoverReview";
+	private static final String REOPEN_ACTION = "action:reopenReview";
+	private static final String REJECT_ACTION = "action:rejectReview";
+	private static final String TRANSITION_ACTION = "/transition?action=";
+
+	private static final String PUBLISH_COMMENTS = "/publish";
+	private static final String COMPLETE_ACTION = "/complete";
+	private static final String UNCOMPLETE_ACTION = "/uncomplete";
+
+	private static final String ADD_CHANGESET = "/addChangeset";
+	private static final String ADD_PATCH = "/addPatch";
+//	private static final String ADD_ITEM = "/addItem";
+
+	private String authToken = null;
+
+	private Map<String, SvnRepository> repositories = new HashMap<String, SvnRepository>();
+	private Map<String, List<CustomFieldDef>> metricsDefinitions = new HashMap<String, List<CustomFieldDef>>();
+
+	/**
+	 * For testing purposes, shouldn't be public
+	 * @param url
+	 * @throws RemoteApiException
+	 */
+	public CrucibleSessionImpl(String url) throws RemoteApiException {
+		this(createServerCfg(url), new HttpSessionCallbackImpl());
+	}
+	
+    private static CrucibleServerCfg createServerCfg(String url) {
+    	CrucibleServerCfg serverCfg = new CrucibleServerCfg(url, new ServerId());
+		serverCfg.setUrl(url);
+		return serverCfg;
+	}
+	
+	/**
+	 * Public constructor for CrucibleSessionImpl.
+	 * 
+	 * @param serverCfg The server fisheye configuration for this session
+	 * @param callback The callback needed for preparing HttpClient calls
+	 * 
+	 * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
+	 *
+	 */
+	public CrucibleSessionImpl(ServerCfg serverCfg, HttpSessionCallback callback) throws RemoteApiMalformedUrlException {
+		super(serverCfg, callback);
+	}
+
+	public void login(String username, String aPassword) throws RemoteApiLoginException {
+		if (!isLoggedIn()) {
+			String loginUrl;
+			try {
+				if (username == null || aPassword == null) {
+					throw new RemoteApiLoginException("Corrupted configuration. Username or Password null");
+				}
+				loginUrl = baseUrl + AUTH_SERVICE + LOGIN + "?userName=" + URLEncoder.encode(username, "UTF-8")
+						+ "&password=" + URLEncoder.encode(aPassword, "UTF-8");
+			} catch (UnsupportedEncodingException e) {
+				///CLOVER:OFF
+				throw new RuntimeException("URLEncoding problem: " + e.getMessage());
+				///CLOVER:ON
+			}
+
+			try {
+				Document doc = retrieveGetResponse(loginUrl);
+				String exception = getExceptionMessages(doc);
+				if (null != exception) {
+					throw new RemoteApiLoginFailedException(exception);
+				}
+				XPath xpath = XPath.newInstance("/loginResult/token");
+				List<?> elements = xpath.selectNodes(doc);
+				if (elements == null) {
+					throw new RemoteApiLoginException("Server did not return any authentication token");
+				}
+				if (elements.size() != 1) {
+					throw new RemoteApiLoginException("Server returned unexpected number of authentication tokens ("
+							+ elements.size() + ")");
+				}
+				this.authToken = ((Element) elements.get(0)).getText();
+				this.userName = username;
+				this.password = aPassword;
+			} catch (MalformedURLException e) {
+				throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
+			} catch (UnknownHostException e) {
+				throw new RemoteApiLoginException("Unknown host: " + e.getMessage(), e);
+			} catch (IOException e) {
+				throw new RemoteApiLoginException(baseUrl + ":" + e.getMessage(), e);
+			} catch (JDOMException e) {
+				throw new RemoteApiLoginException("Server:" + baseUrl + " returned malformed response", e);
+			} catch (RemoteApiSessionExpiredException e) {
+				// Crucible does not return this exception
+			} catch (IllegalArgumentException e) {
+				throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
+			}
+		}
+	}
+
+	public void logout() {
+		if (authToken != null) {
+			authToken = null;
+			userName = null;
+			password = null;
+		}
+	}
+
+	public CrucibleVersionInfo getServerVersion() throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + VERSION;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("versionInfo");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					return CrucibleRestXmlHelper.parseVersionNode(element);
+				}
+			}
+
+			throw new RemoteApiException("No version info found in server response");
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	private void updateMetricsMetadata(Review review) {
+		try {
+			getMetrics(review.getMetricsVersion());
+		} catch (RemoteApiException e) {
+			// can be swallowed - metrics metadata are useful, but not necessery
+		}
+	}
+
+	public List<Review> getReviewsInStates(List<State> states, boolean details) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		StringBuilder sb = new StringBuilder();
+		sb.append(baseUrl);
+		sb.append(REVIEW_SERVICE);
+		if (details) {
+			sb.append(DETAIL_REVIEW_INFO);
+		}
+		if (states != null && states.size() != 0) {
+			sb.append(REVIEWS_IN_STATES);
+			for (Iterator<State> stateIterator = states.iterator(); stateIterator.hasNext();) {
+				State state = stateIterator.next();
+				sb.append(state.value());
+				if (stateIterator.hasNext()) {
+					sb.append(",");
+				}
+			}
+		}
+
+		try {
+			Document doc = retrieveGetResponse(sb.toString());
+
+			XPath xpath;
+			if (details) {
+				xpath = XPath.newInstance("/detailedReviews/detailedReviewData");
+			} else {
+				xpath = XPath.newInstance("/reviews/reviewData");
+			}
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Review> reviews = new ArrayList<Review>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					if (details) {
+						reviews.add(prepareDetailReview(element));
+					} else {
+						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
+					}
+				}
+			}
+			for (Review review : reviews) {
+				updateMetricsMetadata(review);
+			}
+			return reviews;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Review> getAllReviews(boolean details) throws RemoteApiException {
+		return getReviewsInStates(null, details);
+	}
+
+	public List<Review> getReviewsForFilter(PredefinedFilter filter, boolean details) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		try {
+			String url = baseUrl
+					+ REVIEW_SERVICE
+					+ FILTERED_REVIEWS
+					+ "/" + filter.getFilterUrl();
+			if (details) {
+				url += DETAIL_REVIEW_INFO;
+			}
+			Document doc = retrieveGetResponse(url);
+
+			XPath xpath;
+			if (details) {
+				xpath = XPath.newInstance("/detailedReviews/detailedReviewData");
+			} else {
+				xpath = XPath.newInstance("/reviews/reviewData");
+			}
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Review> reviews = new ArrayList<Review>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					if (details) {
+						reviews.add(prepareDetailReview(element));
+					} else {
+						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
+					}
+				}
+			}
+			for (Review review : reviews) {
+				updateMetricsMetadata(review);
+			}
+			return reviews;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Review> getReviewsForCustomFilter(CustomFilter filter, boolean details) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+		Document request = CrucibleRestXmlHelper.prepareCustomFilter(filter);
+
+		try {
+			String url = baseUrl + REVIEW_SERVICE + FILTERED_REVIEWS;
+			if (details) {
+				url += DETAIL_REVIEW_INFO;
+			}
+
+			Document doc = retrievePostResponse(url, request);
+			XPath xpath;
+			if (details) {
+				xpath = XPath.newInstance("/detailedReviews/detailReviewData");
+			} else {
+				xpath = XPath.newInstance("/reviews/reviewData");
+			}
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Review> reviews = new ArrayList<Review>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					if (details) {
+						reviews.add(prepareDetailReview(element));
+					} else {
+						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
+					}
+				}
+			}
+			for (Review review : reviews) {
+				updateMetricsMetadata(review);
+			}
+			return reviews;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Review> getAllReviewsForFile(String repoName, String path, boolean details) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		try {
+			String url = baseUrl
+					+ REVIEW_SERVICE
+					+ SEARCH_REVIEWS
+					+ "/"
+					+ URLEncoder.encode(repoName, "UTF-8");
+			if (details) {
+				url += DETAIL_REVIEW_INFO;
+			}
+			url = url
+					+ SEARCH_REVIEWS_QUERY
+					+ URLEncoder.encode(path, "UTF-8");
+			Document doc = retrieveGetResponse(url);
+
+			XPath xpath;
+			if (details) {
+				xpath = XPath.newInstance("/detailedReviews/detailReviewData");
+			} else {
+				xpath = XPath.newInstance("/reviews/reviewData");
+			}
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Review> reviews = new ArrayList<Review>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					if (details) {
+						reviews.add(prepareDetailReview(element));
+					} else {
+						reviews.add(CrucibleRestXmlHelper.parseReviewNode(baseUrl, element));
+					}
+				}
+			}
+			for (Review review : reviews) {
+				updateMetricsMetadata(review);
+			}
+			return reviews;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public Review getReview(PermId permId, boolean details) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		try {
+			String url = baseUrl
+					+ REVIEW_SERVICE
+					+ "/"
+					+ permId.getId();
+			if (details) {
+				url += DETAIL_REVIEW_INFO;
+			}
+			Document doc = retrieveGetResponse(url);
+
+			XPath xpath;
+			if (details) {
+				xpath = XPath.newInstance("/detailedReviewData");
+			} else {
+				xpath = XPath.newInstance("reviewData");
+			}
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					if (details) {
+						return prepareDetailReview(element);
+					} else {
+						return CrucibleRestXmlHelper.parseReviewNode(baseUrl, element);
+					}
+				}
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void fillRepositoryData(CrucibleFileInfo fileInfo) throws RemoteApiException {
+		String repoName = fileInfo.getRepositoryName();
+		if (repoName == null) {
+			// oh well, it can be null - fileInfos are mostly empty now
+			return;
+		}
+
+		String[] repoNameTokens = repoName.split(":");
+
+		if (!repositories.containsKey(repoName)) {
+			SvnRepository repository = getRepository(repoNameTokens.length > 1 ? repoNameTokens[1] : repoNameTokens[0]);
+			repositories.put(repoName, repository);
+		}
+		SvnRepository repository = repositories.get(repoName);
+		if (repository != null) {
+			String repoPath = repository.getUrl() + "/" + repository.getPath() + "/";
+			VersionedVirtualFile oldDescriptor = fileInfo.getOldFileDescriptor();
+			if (!oldDescriptor.getUrl().equals("")) {
+				oldDescriptor.setRepoUrl(repoPath);
+			}
+			VersionedVirtualFile newDescriptor = fileInfo.getFileDescriptor();
+			if (!newDescriptor.getUrl().equals("")) {
+				newDescriptor.setRepoUrl(repoPath);
+			}
+		}
+	}
+
+	private Review prepareDetailReview(Element element) throws RemoteApiException {
+		ReviewBean review = CrucibleRestXmlHelper.parseDetailedReviewNode(baseUrl, element);
+
+//		for (CrucibleFileInfo fileInfo : CrucibleFileInfoManager.getInstance().getFiles(review)) {
+//			fillRepositoryData(fileInfo);
+//		}
+		try {
+			for (CrucibleFileInfo fileInfo : review.getFiles()) {
+				fillRepositoryData(fileInfo);
+			}
+		} catch (ValueNotYetInitialized valueNotYetInitialized) {
+			// cannot fill
+		}
+		return review;
+	}
+
+	public List<Reviewer> getReviewers(PermId permId) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + REVIEWERS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("/reviewers/reviewer");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Reviewer> reviewers = new ArrayList<Reviewer>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					reviewers.add(CrucibleRestXmlHelper.parseReviewerNode(element));
+				}
+			}
+			return reviewers;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<User> getUsers() throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + USER_SERVICE;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("/users/userData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<User> users = new ArrayList<User>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					users.add(CrucibleRestXmlHelper.parseUserNode(element));
+				}
+			}
+			return users;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Project> getProjects() throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + PROJECTS_SERVICE;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("/projects/projectData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Project> projects = new ArrayList<Project>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					projects.add(CrucibleRestXmlHelper.parseProjectNode(element));
+				}
+			}
+			return projects;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Repository> getRepositories() throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REPOSITORIES_SERVICE;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("/repositories/repoData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Repository> myRepositories = new ArrayList<Repository>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					myRepositories.add(CrucibleRestXmlHelper.parseRepositoryNode(element));
+				}
+			}
+			return myRepositories;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public SvnRepository getRepository(String repoName) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		List<Repository> myRepositories = getRepositories();
+		for (Repository repository : myRepositories) {
+			if (repository.getName().equals(repoName)) {
+				if (repository.getType().equals("svn")) {
+					String requestUrl = baseUrl + REPOSITORIES_SERVICE + "/" + repoName + "/svn";
+					try {
+						Document doc = retrieveGetResponse(requestUrl);
+						XPath xpath = XPath.newInstance("/svnRepositoryData");
+						@SuppressWarnings("unchecked")
+						List<Element> elements = xpath.selectNodes(doc);
+						if (elements != null && !elements.isEmpty()) {
+							for (Element element : elements) {
+								return CrucibleRestXmlHelper.parseSvnRepositoryNode(element);
+							}
+						}
+					} catch (IOException e) {
+						throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+					} catch (JDOMException e) {
+						throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+					}
+				}
+			}
+		}
+		return null;
+	}
+
+	public List<CrucibleFileInfo> getFiles(PermId id) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + REVIEW_ITEMS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("reviewItems/reviewItem");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<CrucibleFileInfo> reviewItems = new ArrayList<CrucibleFileInfo>();
+
+			Review changeSet = new ReviewBean(baseUrl);
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					CrucibleFileInfo fileInfo = CrucibleRestXmlHelper.parseReviewItemNode(changeSet, element);
+					fillRepositoryData(fileInfo);
+					reviewItems.add(fileInfo);
+				}
+			}
+			return reviewItems;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+//	public CrucibleFileInfo addItemToReview(Review review, NewReviewItem item) throws RemoteApiException {
+//		if (!isLoggedIn()) {
+//			throw new IllegalStateException("Calling method without calling login() first");
+//		}
+//
+//		Document request = CrucibleRestXmlHelper.prepareAddItemNode(item);
+//		try {
+//			String url = baseUrl + REVIEW_SERVICE + "/" + review.getPermId().getId() + REVIEW_ITEMS;
+//			Document doc = retrievePostResponse(url, request);
+//			XPath xpath = XPath.newInstance("/reviewItem");
+//			@SuppressWarnings("unchecked")
+//			List<Element> elements = xpath.selectNodes(doc);
+//
+//			if (elements != null && !elements.isEmpty()) {
+//				CrucibleFileInfo fileInfo = CrucibleRestXmlHelper.parseReviewItemNode(review, elements.iterator().next());
+//				fillRepositoryData(fileInfo);
+//				CrucibleFileInfoManager.getInstance().getFiles(review).add(fileInfo);
+//				return fileInfo;
+//			}
+//			return null;
+//		} catch (IOException e) {
+//			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+//		} catch (JDOMException e) {
+//			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+//		}
+//	}
+
+	public List<GeneralComment> getGeneralComments(PermId id) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + GENERAL_COMMENTS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("comments/generalCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<GeneralComment> comments = new ArrayList<GeneralComment>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					comments.add(CrucibleRestXmlHelper.parseGeneralCommentNode(element));
+				}
+			}
+			return comments;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<VersionedComment> getAllVersionedComments(PermId id) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + VERSIONED_COMMENTS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("comments/versionedLineCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<VersionedComment> comments = new ArrayList<VersionedComment>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					comments.add(CrucibleRestXmlHelper.parseVersionedCommentNode(element));
+				}
+			}
+			return comments;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<VersionedComment> getVersionedComments(PermId id, PermId reviewItemId) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + REVIEW_ITEMS + "/" + reviewItemId.getId() + COMMENTS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("comments/versionedLineCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<VersionedComment> comments = new ArrayList<VersionedComment>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					comments.add(CrucibleRestXmlHelper.parseVersionedCommentNode(element));
+				}
+			}
+			return comments;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<GeneralComment> getReplies(PermId id, PermId commentId) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + commentId.getId() + REPLIES;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("comments/generalCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<GeneralComment> comments = new ArrayList<GeneralComment>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					comments.add(CrucibleRestXmlHelper.parseGeneralCommentNode(element));
+				}
+			}
+			return comments;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+//	public List<Comment> getComments(PermId id) throws RemoteApiException {
+//		if (!isLoggedIn()) {
+//			throw new IllegalStateException("Calling method without calling login() first");
+//		}
+//
+//		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS;
+//		try {
+//			Document doc = retrieveGetResponse(requestUrl);
+//
+//			XPath xpath = XPath.newInstance("comments/generalCommentData");
+//			@SuppressWarnings("unchecked")
+//			List<Element> elements = xpath.selectNodes(doc);
+//			List<Comment> comments = new ArrayList<Comment>();
+//
+//			if (elements != null && !elements.isEmpty()) {
+//				int i = 1;
+//				for (Element element : elements) {
+//					GeneralCommentBean comment = CrucibleRestXmlHelper.parseGeneralCommentNode(element);
+//					XPath repliesPath = XPath.newInstance("comments/generalCommentData[" + (i++)
+//							+ "]/replies/generalCommentData");
+//					@SuppressWarnings("unchecked")
+//					final List<Element> replies = repliesPath.selectNodes(doc);
+//					if (replies != null && !replies.isEmpty()) {
+//						for (Element reply : replies) {
+//							comment.addReply(CrucibleRestXmlHelper.parseGeneralCommentNode(reply));
+//						}
+//					}
+//					comments.add(comment);
+//				}
+//			}
+//
+//			xpath = XPath.newInstance("comments/versionedLineCommentData");
+//			@SuppressWarnings("unchecked")
+//			List<Element> vElements = xpath.selectNodes(doc);
+//
+//			if (vElements != null && !vElements.isEmpty()) {
+//				int i = 1;
+//				for (Element element : vElements) {
+//					VersionedCommentBean comment = CrucibleRestXmlHelper.parseVersionedCommentNode(element);
+//					XPath repliesPath = XPath.newInstance("comments/versionedLineCommentData[" + (i++)
+//							+ "]/replies/generalCommentData");
+//					@SuppressWarnings("unchecked")
+//					final List<Element> replies = repliesPath.selectNodes(doc);
+//					if (replies != null && !replies.isEmpty()) {
+//						for (Element reply : replies) {
+//							comment.addReply(CrucibleRestXmlHelper.parseVersionedCommentNode(reply));
+//						}
+//					}
+//					comments.add(comment);
+//				}
+//			}
+//
+//			return comments;
+//		} catch (IOException e) {
+//			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+//		} catch (JDOMException e) {
+//			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+//		}
+//	}
+
+	public GeneralComment addGeneralComment(PermId id, GeneralComment comment) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS;
+		try {
+			Document doc = retrievePostResponse(requestUrl, request);
+
+			XPath xpath = XPath.newInstance("generalCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					return CrucibleRestXmlHelper.parseGeneralCommentNode(element);
+				}
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void removeComment(PermId id, Comment comment) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + comment.getPermId().getId();
+		try {
+			retrieveDeleteResponse(requestUrl, false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void updateComment(PermId id, Comment comment) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + comment.getPermId().getId();
+
+		try {
+			retrievePostResponse(requestUrl, request, false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void publishComment(PermId reviewId, PermId commentId) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + reviewId.getId() + PUBLISH_COMMENTS;
+		if (commentId != null) {
+			requestUrl += "/" + commentId.getId();
+		}
+
+		try {
+			retrievePostResponse(requestUrl, "", false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		} catch (RemoteApiSessionExpiredException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		}
+	}
+
+	public VersionedComment addVersionedComment(PermId id, PermId riId, VersionedComment comment) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareVersionedComment(riId, comment);
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + REVIEW_ITEMS + "/"
+				+ riId.getId() + COMMENTS;
+		try {
+			Document doc = retrievePostResponse(requestUrl, request);
+			XPath xpath = XPath.newInstance("versionedLineCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					return CrucibleRestXmlHelper.parseVersionedCommentNode(element);
+				}
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public GeneralComment addGeneralCommentReply(PermId id, PermId cId, GeneralComment comment) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + cId.getId() + REPLIES;
+
+		try {
+			Document doc = retrievePostResponse(requestUrl, request);
+
+			XPath xpath = XPath.newInstance("generalCommentData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					GeneralCommentBean reply = CrucibleRestXmlHelper.parseGeneralCommentNode(element);
+					reply.setReply(true);
+					return reply;
+				}
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public VersionedComment addVersionedCommentReply(PermId id, PermId cId, VersionedComment comment)
+			throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/" + cId.getId() + REPLIES;
+
+		try {
+			Document doc = retrievePostResponse(requestUrl, request);
+
+			XPath xpath = XPath.newInstance("generalCommentData");  // todo lguminski we should change it to reflect model
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					VersionedCommentBean reply = CrucibleRestXmlHelper.parseVersionedCommentNode(element);
+					reply.setReply(true);
+					return reply;
+				}
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+
+	}
+
+	public void updateReply(PermId id, PermId cId, PermId rId, GeneralComment comment) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareGeneralComment(comment);
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + id.getId() + COMMENTS + "/"
+				+ cId.getId() + REPLIES + "/" + rId.getId();
+
+		try {
+			retrievePostResponse(requestUrl, request, false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public Review createReview(Review review) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+		return createReviewFromPatch(review, null);
+	}
+
+	public Review createReviewFromPatch(Review review, String patch) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareCreateReviewNode(review, patch);
+		try {
+			Document doc = retrievePostResponse(baseUrl + REVIEW_SERVICE, request);
+
+			XPath xpath = XPath.newInstance("/reviewData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public Review createReviewFromRevision(Review review, List<String> revisions) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareCreateReviewNode(review, revisions);
+
+//		XmlUtil.printXml(request);
+
+		try {
+			Document doc = retrievePostResponse(baseUrl + REVIEW_SERVICE, request);
+			XPath xpath = XPath.newInstance("/reviewData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Action> getAvailableActions(PermId permId) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + ACTIONS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("/actions/actionData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Action> actions = new ArrayList<Action>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					actions.add(CrucibleRestXmlHelper.parseActionNode(element));
+				}
+			}
+			return actions;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<Action> getAvailableTransitions(PermId permId) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + TRANSITIONS;
+		try {
+			Document doc = retrieveGetResponse(requestUrl);
+
+			XPath xpath = XPath.newInstance("/transitions/actionData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			List<Action> transitions = new ArrayList<Action>();
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					transitions.add(CrucibleRestXmlHelper.parseActionNode(element));
+				}
+			}
+			return transitions;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public Review addRevisionsToReview(PermId permId, String repository, List<String> revisions) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareAddChangesetNode(repository, revisions);
+
+		try {
+			String url = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + ADD_CHANGESET;
+			Document doc = retrievePostResponse(url, request);
+
+
+			XPath xpath = XPath.newInstance("/reviewData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public Review addPatchToReview(PermId permId, String repository, String patch) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		Document request = CrucibleRestXmlHelper.prepareAddPatchNode(repository, patch);
+
+		try {
+			String url = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + ADD_PATCH;
+			Document doc = retrievePostResponse(url, request);
+
+			XPath xpath = XPath.newInstance("/reviewData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+
+			if (elements != null && !elements.isEmpty()) {
+				return CrucibleRestXmlHelper.parseReviewNode(baseUrl, elements.iterator().next());
+			}
+			return null;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void addReviewers(PermId permId, Set<String> users) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + REVIEWERS;
+		String reviewers = "";
+		for (String user : users) {
+			if (reviewers.length() > 0) {
+				reviewers += ",";
+			}
+			reviewers += user;
+		}
+
+		try {
+			retrievePostResponse(requestUrl, reviewers, false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void removeReviewer(PermId permId, String username) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + REVIEWERS + "/" + username;
+		try {
+			retrieveDeleteResponse(requestUrl, false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	private Review changeReviewState(PermId permId, String action) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + TRANSITION_ACTION + action;
+		try {
+			Document doc = retrievePostResponse(requestUrl, "", true);
+
+			XPath xpath = XPath.newInstance("reviewData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			Review review = null;
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					review = CrucibleRestXmlHelper.parseReviewNode(baseUrl, element);
+				}
+			}
+			return review;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public void completeReview(PermId permId, boolean complete) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId();
+		if (complete) {
+			requestUrl += COMPLETE_ACTION;
+		} else {
+			requestUrl += UNCOMPLETE_ACTION;
+		}
+
+		try {
+			retrievePostResponse(requestUrl, "", false);
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public Review approveReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, APPROVE_ACTION);
+	}
+
+	public Review submitReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, SUBMIT_ACTION);
+	}
+
+	public Review abandonReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, ABANDON_ACTION);
+	}
+
+	public Review summarizeReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, SUMMARIZE_ACTION);
+	}
+
+	public Review recoverReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, RECOVER_ACTION);
+	}
+
+	public Review reopenReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, REOPEN_ACTION);
+	}
+
+	public Review rejectReview(PermId permId) throws RemoteApiException {
+		return changeReviewState(permId, REJECT_ACTION);
+	}
+
+	public Review closeReview(PermId permId, String summarizeMessage) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		try {
+			Document doc;
+			if (summarizeMessage != null && !"".equals(summarizeMessage)) {
+				Document request = CrucibleRestXmlHelper.prepareCloseReviewSummaryNode(summarizeMessage);
+				String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + "/close";
+				doc = retrievePostResponse(requestUrl, request);
+			} else {
+				String requestUrl = baseUrl + REVIEW_SERVICE + "/" + permId.getId() + TRANSITION_ACTION + CLOSE_ACTION;
+				doc = retrievePostResponse(requestUrl, "", true);
+			}
+
+			XPath xpath = XPath.newInstance("reviewData");
+			@SuppressWarnings("unchecked")
+			List<Element> elements = xpath.selectNodes(doc);
+			Review review = null;
+
+			if (elements != null && !elements.isEmpty()) {
+				for (Element element : elements) {
+					review = CrucibleRestXmlHelper.parseReviewNode(baseUrl, element);
+				}
+			}
+			return review;
+		} catch (IOException e) {
+			throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+		} catch (JDOMException e) {
+			throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+		}
+	}
+
+	public List<CustomFieldDef> getMetrics(int version) throws RemoteApiException {
+		if (!isLoggedIn()) {
+			throw new IllegalStateException("Calling method without calling login() first");
+		}
+
+		String key = Integer.toString(version);
+		if (!metricsDefinitions.containsKey(key)) {
+			String requestUrl = baseUrl + REVIEW_SERVICE + METRICS + "/" + Integer.toString(version);
+			try {
+				Document doc = retrieveGetResponse(requestUrl);
+
+				XPath xpath = XPath.newInstance("metrics/metricsData");
+				@SuppressWarnings("unchecked")
+				List<Element> elements = xpath.selectNodes(doc);
+				List<CustomFieldDef> metrics = new ArrayList<CustomFieldDef>();
+
+				if (elements != null && !elements.isEmpty()) {
+					for (Element element : elements) {
+						metrics.add(CrucibleRestXmlHelper.parseMetricsNode(element));
+					}
+				}
+				metricsDefinitions.put(key, metrics);
+			} catch (IOException e) {
+				throw new RemoteApiException(baseUrl + ": " + e.getMessage(), e);
+			} catch (JDOMException e) {
+				throw new RemoteApiException(baseUrl + ": Server returned malformed response", e);
+			}
+		}
+		return metricsDefinitions.get(key);
+	}
+
+	@Override
+	protected void adjustHttpHeader(HttpMethod method) {
+		method.addRequestHeader(new Header("Authorization", getAuthHeaderValue()));
+	}
+	
+
+	@Override
+	protected void preprocessResult(Document doc) throws JDOMException, RemoteApiSessionExpiredException {
+
+	}
+
+	private String getAuthHeaderValue() {
+		return "Basic " + encode(userName + ":" + password);
+	}
+
+	private synchronized String encode(String str2encode) {
+		try {
+			Base64 base64 = new Base64();
+			byte[] bytes = base64.encode(str2encode.getBytes("UTF-8"));
+			return new String(bytes);
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException("UTF-8 is not supported", e);
+		}
+	}
+
+	private static String getExceptionMessages(Document doc) throws JDOMException {
+		XPath xpath = XPath.newInstance("/loginResult/error");
+		@SuppressWarnings("unchecked")
+		List<Element> elements = xpath.selectNodes(doc);
+
+		if (elements != null && elements.size() > 0) {
+			StringBuffer exceptionMsg = new StringBuffer();
+			for (Element e : elements) {
+				exceptionMsg.append(e.getText());
+				exceptionMsg.append("\n");
+			}
+			return exceptionMsg.toString();
+		} else {
+			/* no exception */
+			return null;
+		}
+	}
+
+	public boolean isLoggedIn() {
+		return authToken != null;
+	}
 }
\ No newline at end of file
Index: src/main/java/com/atlassian/theplugin/commons/fisheye/FishEyeServerFacade.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/fisheye/FishEyeServerFacade.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/fisheye/FishEyeServerFacade.java	(working copy)
@@ -18,6 +18,7 @@
 import com.atlassian.theplugin.commons.cfg.FishEyeServer;
 import com.atlassian.theplugin.commons.remoteapi.ProductServerFacade;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
 
 import java.util.Collection;
 
@@ -28,4 +29,6 @@
 	
 	Collection<String> getRepositories(final FishEyeServer server) throws RemoteApiException;
 
+	public void setCallback(HttpSessionCallback callback);
+
 }
Index: src/main/java/com/atlassian/theplugin/commons/fisheye/FishEyeServerFacadeImpl.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/fisheye/FishEyeServerFacadeImpl.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/fisheye/FishEyeServerFacadeImpl.java	(working copy)
@@ -1,26 +1,46 @@
 package com.atlassian.theplugin.commons.fisheye;
 
+import java.util.Collection;
+
 import com.atlassian.theplugin.commons.ServerType;
 import com.atlassian.theplugin.commons.cfg.FishEyeServer;
+import com.atlassian.theplugin.commons.cfg.FishEyeServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerId;
 import com.atlassian.theplugin.commons.fisheye.api.FishEyeSession;
 import com.atlassian.theplugin.commons.fisheye.api.rest.FishEyeRestSession;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
 
-import java.util.Collection;
-
 /**
  * User: pmaruszak
  */
 public class FishEyeServerFacadeImpl implements FishEyeServerFacade {
 	private static FishEyeServerFacadeImpl instance;
-
+	private HttpSessionCallback callback;
+	
 	protected FishEyeServerFacadeImpl() {
+		this.callback = new HttpSessionCallbackImpl();
 	}
+		
+	/**
+     * For testing Only
+     * @see com.atlassian.theplugin.commons.remoteapi.ProductServerFacade#testServerConnection(java.lang.String, java.lang.String, java.lang.String)
+     */
+    public void testServerConnection(String url, String userName, String password) throws RemoteApiException {
+    	FishEyeServerCfg serverCfg = new FishEyeServerCfg(url, new ServerId());
+    	serverCfg.setUrl(url);
+    	serverCfg.setUsername(userName);
+    	serverCfg.setPassword(password);
+    	testServerConnection(serverCfg);
+    }
 	
-	public void testServerConnection(final String url, final String userName, final String password) throws RemoteApiException {
-		FishEyeSession fishEyeSession = getSession(url);
-		fishEyeSession.login(userName, password.toCharArray());
+	public void testServerConnection(ServerCfg serverCfg) throws RemoteApiException {
+		assert(serverCfg instanceof FishEyeServerCfg);
+		FishEyeSession fishEyeSession = getSession((FishEyeServerCfg)serverCfg);
+		fishEyeSession.login(serverCfg.getUsername(), serverCfg.getPassword().toCharArray());
 		fishEyeSession.logout();		
 	}
 
@@ -36,14 +56,27 @@
 		return instance;
 	}
 
+	/**
+	 * For testing Only
+	 * 
+	 * @param server
+	 * @return
+	 * @throws RemoteApiMalformedUrlException
+	 */
+	public FishEyeSession getSession(String url) throws RemoteApiMalformedUrlException {
+		FishEyeServerCfg serverCfg = new FishEyeServerCfg(url, new ServerId());
+		serverCfg.setUrl(url);
+		return new FishEyeRestSession(serverCfg, callback);
 
-	public FishEyeSession getSession(final String url) throws RemoteApiMalformedUrlException {
-		return new FishEyeRestSession(url);
+	}
+	
+	public FishEyeSession getSession(FishEyeServer server) throws RemoteApiMalformedUrlException {
+		return new FishEyeRestSession(server, callback);
 
 	}
-	
+
 	public Collection<String> getRepositories(final FishEyeServer server) throws RemoteApiException {
-		FishEyeSession fishEyeSession = getSession(server.getUrl());
+		FishEyeSession fishEyeSession = getSession(server);
 		Collection<String> repositories;
 		
 		fishEyeSession.login(server.getUsername(), server.getPassword().toCharArray());
@@ -51,4 +84,8 @@
 		fishEyeSession.logout();
 		return repositories;
 	}
+	
+	public void setCallback(HttpSessionCallback callback) {
+		this.callback = callback;
+	}
 }
Index: src/main/java/com/atlassian/theplugin/commons/fisheye/api/rest/FishEyeRestSession.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/fisheye/api/rest/FishEyeRestSession.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/fisheye/api/rest/FishEyeRestSession.java	(working copy)
@@ -15,22 +15,33 @@
  */
 package com.atlassian.theplugin.commons.fisheye.api.rest;
 
-import com.atlassian.theplugin.commons.fisheye.api.FishEyeSession;
-import com.atlassian.theplugin.commons.remoteapi.*;
-import com.atlassian.theplugin.commons.remoteapi.rest.AbstractHttpSession;
-import com.atlassian.theplugin.commons.util.LoggerImpl;
-import com.atlassian.theplugin.commons.util.UrlUtil;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.commons.httpclient.HttpMethod;
 import org.jdom.Document;
 import org.jdom.Element;
 import org.jdom.JDOMException;
 import org.jdom.xpath.XPath;
 
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
+import com.atlassian.theplugin.commons.cfg.FishEyeServer;
+import com.atlassian.theplugin.commons.cfg.FishEyeServerCfg;
+import com.atlassian.theplugin.commons.cfg.Server;
+import com.atlassian.theplugin.commons.cfg.ServerId;
+import com.atlassian.theplugin.commons.fisheye.api.FishEyeSession;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginFailedException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiSessionExpiredException;
+import com.atlassian.theplugin.commons.remoteapi.rest.AbstractHttpSession;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
+import com.atlassian.theplugin.commons.util.LoggerImpl;
+import com.atlassian.theplugin.commons.util.UrlUtil;
 
 public class FishEyeRestSession extends AbstractHttpSession implements FishEyeSession {
 	static final String REST_BASE_URL = "/api/rest/";
@@ -40,14 +51,31 @@
 	private String authToken;
 
 	/**
+	 * For testing purposes
+	 * @param url
+	 * @throws RemoteApiException
+	 */
+	FishEyeRestSession(String url) throws RemoteApiMalformedUrlException {
+		this(createServerCfg(url), new HttpSessionCallbackImpl());
+	}
+	
+    private static FishEyeServer createServerCfg(String url) {
+    	FishEyeServerCfg serverCfg = new FishEyeServerCfg(url, new ServerId());
+		serverCfg.setUrl(url);
+		return serverCfg;
+	}
+	
+	/**
 	 * Public constructor for AbstractHttpSession
 	 *
-	 * @param baseUrl base URL for server instance
+	 * @param serverCfg The server configuration for this session
+	 * @param callback The callback needed for preparing HttpClient calls
+	 * 
 	 * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
 	 *          for malformed url
 	 */
-	public FishEyeRestSession(String baseUrl) throws RemoteApiMalformedUrlException {
-		super(baseUrl);		
+	public FishEyeRestSession(Server server, HttpSessionCallback callback) throws RemoteApiMalformedUrlException {
+		super(server, callback);		
 	}
 
 	@Override
Index: src/main/java/com/atlassian/theplugin/commons/bamboo/BambooServerFacade.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/bamboo/BambooServerFacade.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/bamboo/BambooServerFacade.java	(working copy)
@@ -20,6 +20,7 @@
 import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
 import com.atlassian.theplugin.commons.remoteapi.ProductServerFacade;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
 
 import java.util.Collection;
 
@@ -47,4 +48,7 @@
 
     byte[] getBuildLogs(BambooServerCfg server, String buildKey, String buildNumber)
             throws ServerPasswordNotProvidedException, RemoteApiException;
+    
+	public void setCallback(HttpSessionCallback callback);
+
 }
Index: src/main/java/com/atlassian/theplugin/commons/bamboo/api/BambooSessionImpl.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/bamboo/api/BambooSessionImpl.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/bamboo/api/BambooSessionImpl.java	(working copy)
@@ -1,610 +1,631 @@
-/**
- * Copyright (C) 2008 Atlassian
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.atlassian.theplugin.commons.bamboo.api;
-
-import com.atlassian.theplugin.commons.BambooFileInfo;
-import com.atlassian.theplugin.commons.BambooFileInfoImpl;
-import com.atlassian.theplugin.commons.bamboo.*;
-import com.atlassian.theplugin.commons.remoteapi.*;
-import com.atlassian.theplugin.commons.remoteapi.rest.AbstractHttpSession;
-import com.atlassian.theplugin.commons.util.UrlUtil;
-import org.apache.commons.httpclient.HttpMethod;
-import org.jdom.Document;
-import org.jdom.Element;
-import org.jdom.JDOMException;
-import org.jdom.xpath.XPath;
-import org.joda.time.format.DateTimeFormat;
-import org.joda.time.format.DateTimeFormatter;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.MalformedURLException;
-import java.net.URLEncoder;
-import java.net.UnknownHostException;
-import java.util.*;
-
-/*
-@todo get logs based on url: BASE_URL/download/TP-TEST/build_logs/TP-TEST-341.log
- */
-
-/**
- * Communication stub for Bamboo REST API.
- */
-public class BambooSessionImpl extends AbstractHttpSession implements BambooSession {
-    private static final String LOGIN_ACTION = "/api/rest/login.action";
-    private static final String LOGOUT_ACTION = "/api/rest/logout.action";
-    private static final String LIST_PROJECT_ACTION = "/api/rest/listProjectNames.action";
-    private static final String LIST_PLAN_ACTION = "/api/rest/listBuildNames.action";
-    private static final String LATEST_BUILD_FOR_PLAN_ACTION = "/api/rest/getLatestBuildResults.action";
-    private static final String LATEST_USER_BUILDS_ACTION = "/api/rest/getLatestUserBuilds.action";
-    private static final String GET_BUILD_DETAILS_ACTION = "/api/rest/getBuildResultsDetails.action";
-    private static final String ADD_LABEL_ACTION = "/api/rest/addLabelToBuildResults.action";
-    private static final String ADD_COMMENT_ACTION = "/api/rest/addCommentToBuildResults.action";
-    private static final String EXECUTE_BUILD_ACTION = "/api/rest/executeBuild.action";
-    private static final String GET_BAMBOO_BUILD_NUMBER_ACTION = "/api/rest/getBambooBuildNumber.action";
-
-    private String authToken;
-
-    private static final String AUTHENTICATION_ERROR_MESSAGE = "User not authenticated yet, or session timed out";
-
-    /**
-     * Public constructor for BambooSessionImpl.
-     *
-     * @param baseUrl base URL for Bamboo instance
-     * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
-     *
-     */
-    public BambooSessionImpl(String baseUrl) throws RemoteApiMalformedUrlException {
-        super(baseUrl);
-    }
-
-
-    /**
-     * Connects to Bamboo server instance. On successful login authentication token is returned from
-     * server and stored in Bamboo session for subsequent calls.
-     * <p/>
-     * The exception returned may have the getCause() examined for to get the actual exception reason.<br>
-     * If the exception is caused by a valid error response from the server (no IOEXception, UnknownHostException,
-     * MalformedURLException or JDOMException), the
-     * {@link com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginFailedException}
-     * is actually thrown. This may be used as a hint that the password is invalid.
-     *
-     * @param name      username defined on Bamboo server instance
-     * @param aPassword for username
-     * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginException
-     *          on connection or authentication errors
-     */
-    public void login(String name, char[] aPassword) throws RemoteApiLoginException {
-        String loginUrl;
-
-		if (name == null || aPassword == null) {
-			throw new RemoteApiLoginException("Corrupted configuration. Username or Password null");
-		}
-		String pass = String.valueOf(aPassword);
-		loginUrl = baseUrl + LOGIN_ACTION + "?username=" + UrlUtil.encodeUrl(name) + "&password="
-				+ UrlUtil.encodeUrl(pass) + "&os_username="
-				+ UrlUtil.encodeUrl(name) + "&os_password=" + UrlUtil.encodeUrl(pass);
-
-
-		try {
-            Document doc = retrieveGetResponse(loginUrl);
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                throw new RemoteApiLoginFailedException(exception);
-            }
-
-            @SuppressWarnings("unchecked")
-            final List<Element> elements = XPath.newInstance("/response/auth").selectNodes(doc);
-            if (elements == null || elements.size() == 0) {
-                throw new RemoteApiLoginException("Server did not return any authentication token");
-            }
-            if (elements.size() != 1) {
-                throw new RemoteApiLoginException("Server returned unexpected number of authentication tokens ("
-						+ elements.size() + ")");
-            }
-            this.authToken = elements.get(0).getText();
-        } catch (MalformedURLException e) {
-            throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
-        } catch (UnknownHostException e) {
-            throw new RemoteApiLoginException("Unknown host: " + e.getMessage(), e);
-        } catch (IOException e) {
-            throw new RemoteApiLoginException(e.getMessage(), e);
-        } catch (JDOMException e) {
-            throw new RemoteApiLoginException("Server returned malformed response", e);
-        } catch (RemoteApiSessionExpiredException e) {
-            throw new RemoteApiLoginException("Session expired", e);
-        } catch (IllegalArgumentException e) {
-            throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
-        }
-
-    }
-
-    public void logout() {
-        if (!isLoggedIn()) {
-            return;
-        }
-
-        try {
-            String logoutUrl = baseUrl + LOGOUT_ACTION + "?auth=" + URLEncoder.encode(authToken, "UTF-8");
-            retrieveGetResponse(logoutUrl);
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException("URLEncoding problem", e);
-        } catch (IOException e) {
-            /* ignore errors on logout */
-        } catch (JDOMException e) {
-            /* ignore errors on logout */
-        } catch (RemoteApiSessionExpiredException e) {
-            /* ignore errors on logout */
-        }
-
-
-        authToken = null;
-        client = null;
-    }
-
-    public int getBamboBuildNumber() throws RemoteApiException {
-        String queryUrl = baseUrl + GET_BAMBOO_BUILD_NUMBER_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
-
-        try {
-            Document doc = retrieveGetResponse(queryUrl);
-
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                // error - method does nt exists (session errors handled in retrieveGetReponse
-                return -1;
-            }
-
-            XPath xpath = XPath.newInstance("/response/bambooBuildNumber");
-            @SuppressWarnings("unchecked")
-            Element element = (Element) xpath.selectSingleNode(doc);
-            if (element != null) {
-                String bNo = element.getText();
-                return Integer.parseInt(bNo);
-            }
-            return -1;
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-    }
-
-    public List<BambooProject> listProjectNames() throws RemoteApiException {
-        String buildResultUrl = baseUrl + LIST_PROJECT_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
-
-        List<BambooProject> projects = new ArrayList<BambooProject>();
-        try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-            XPath xpath = XPath.newInstance("/response/project");
-            @SuppressWarnings("unchecked")
-            List<Element> elements = xpath.selectNodes(doc);
-            if (elements != null) {
-                for (Element element : elements) {
-                    String name = element.getChild("name").getText();
-                    String key = element.getChild("key").getText();
-                    projects.add(new BambooProjectInfo(name, key));
-                }
-            }
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-
-        return projects;
-    }
-
-    public List<BambooPlan> listPlanNames() throws RemoteApiException {
-        String buildResultUrl = baseUrl + LIST_PLAN_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
-
-        List<BambooPlan> plans = new ArrayList<BambooPlan>();
-        try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-            XPath xpath = XPath.newInstance("/response/build");
-            @SuppressWarnings("unchecked")
-            List<Element> elements = xpath.selectNodes(doc);
-            if (elements != null) {
-                for (Element element : elements) {
-                    String enabledValue = element.getAttributeValue("enabled");
-                    boolean enabled = true;
-                    if (enabledValue != null) {
-                        enabled = Boolean.parseBoolean(enabledValue);
-                    }
-                    String name = element.getChild("name").getText();
-                    String key = element.getChild("key").getText();
-                    BambooPlanData plan = new BambooPlanData(name, key);
-                    plan.setEnabled(enabled);
-                    plans.add(plan);
-                }
-            }
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-
-        return plans;
-    }
-
-    /**
-     * Returns a {@link com.atlassian.theplugin.commons.bamboo.BambooBuild} information about the latest build in a plan.
-     * <p/>
-     * Returned structure contains either the information about the build or an error message if the connection fails.
-     *
-     * @param planKey ID of the plan to get info about
-     * @return Information about the last build or error message
-     */
-    public BambooBuild getLatestBuildForPlan(String planKey) throws RemoteApiSessionExpiredException {
-        String buildResultUrl = baseUrl + LATEST_BUILD_FOR_PLAN_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
-                    + "&buildKey=" + UrlUtil.encodeUrl(planKey);
-
-        try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-//			XmlUtil.printXml(doc);
-			String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                return constructBuildErrorInfo(planKey, exception, new Date());
-            }
-
-            @SuppressWarnings("unchecked")
-            final List elements = XPath.newInstance("/response").selectNodes(doc);
-            if (elements != null && !elements.isEmpty()) {
-                Element e = (Element) elements.iterator().next();
-				BambooBuildInfo build = constructBuildItem(e, new Date());
-				build.setCommiters(constructBuildCommiters(doc));
-				return build;
-            } else {
-                return constructBuildErrorInfo(planKey, "Malformed server reply: no response element", new Date());
-            }
-        } catch (IOException e) {
-            return constructBuildErrorInfo(planKey, e.getMessage(), new Date());
-        } catch (JDOMException e) {
-            return constructBuildErrorInfo(planKey, "Server returned malformed response", new Date());
-        } catch (RemoteApiException e) {
-            return constructBuildErrorInfo(planKey, e.getMessage(), new Date());
-        }
-    }
-
-	private Set<String> constructBuildCommiters(final Document doc) throws JDOMException {
-
-		Set<String> commiters = new HashSet<String>();
-		@SuppressWarnings("unchecked")
-		final List<Element> commitElements = XPath.newInstance("/response/commits/commit").selectNodes(doc);
-		if (!commitElements.isEmpty()) {
-
-			for (Element element : commitElements) {
-				commiters.add(element.getAttributeValue("author"));
-			}
-		}
-
-		return commiters;
-	}
-
-	public List<String> getFavouriteUserPlans() throws RemoteApiSessionExpiredException {
-        List<String> builds = new ArrayList<String>();
-        String buildResultUrl = baseUrl + LATEST_USER_BUILDS_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
-
-        try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                return builds;
-            }
-
-            final XPath xpath = XPath.newInstance("/response/build");
-            @SuppressWarnings("unchecked")
-            final List<Element> elements = xpath.selectNodes(doc);
-            if (elements != null) {
-                for (Element element : elements) {
-                    builds.add(element.getChildText("key"));
-                }
-                return builds;
-            } else {
-                return builds;
-            }
-        } catch (IOException e) {
-            return builds;
-        } catch (JDOMException e) {
-            return builds;
-        }
-    }
-
-    public BuildDetails getBuildResultDetails(String buildKey, String buildNumber) throws RemoteApiException {
-		String buildResultUrl;
-
-
-		buildResultUrl = baseUrl + GET_BUILD_DETAILS_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
-				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey)
-				+ "&buildNumber=" + UrlUtil.encodeUrl(buildNumber);
-
-
-		try {
-            BuildDetailsInfo build = new BuildDetailsInfo();
-            Document doc = retrieveGetResponse(buildResultUrl);
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                throw new RemoteApiException(exception);
-            }
-
-            @SuppressWarnings("unchecked")
-            final List<Element> responseElements = XPath.newInstance("/response").selectNodes(doc);
-            for (Element element : responseElements) {
-                String vcsRevisionKey = element.getAttributeValue("vcsRevisionKey");
-                if (vcsRevisionKey != null) {
-                    build.setVcsRevisionKey(vcsRevisionKey);
-                }
-            }
-
-            @SuppressWarnings("unchecked")
-                final List<Element> commitElements = XPath.newInstance("/response/commits/commit").selectNodes(doc);
-                if (!commitElements.isEmpty()) {
-                    int i = 1;
-                    for (Element element : commitElements) {
-                        BambooChangeSetImpl cInfo = new BambooChangeSetImpl();
-                        cInfo.setAuthor(element.getAttributeValue("author"));
-                        cInfo.setCommitDate(parseCommitTime(element.getAttributeValue("date")));
-                        cInfo.setComment(getChildText(element, "comment"));
-
-                        String path = "/response/commits/commit[" + i++ + "]/files/file";
-                        XPath filesPath = XPath.newInstance(path);
-                        @SuppressWarnings("unchecked")
-                        final List<Element> fileElements = filesPath.selectNodes(doc);
-                        for (Element file : fileElements) {
-                            BambooFileInfo fileInfo = new BambooFileInfoImpl(
-                                    cInfo.getVirtualFileSystem(),
-                                    file.getAttributeValue("name"),
-                                    file.getAttributeValue("revision"));
-                            cInfo.addCommitFile(fileInfo);
-                        }
-                        build.addCommitInfo(cInfo);
-                    }
-                }
-
-            @SuppressWarnings("unchecked")
-            final List<Element> sucTestResElements
-                    = XPath.newInstance("/response/successfulTests/testResult").selectNodes(doc);
-            for (Element element : sucTestResElements) {
-                TestDetailsInfo tInfo = new TestDetailsInfo();
-                tInfo.setTestClassName(element.getAttributeValue("testClass"));
-                tInfo.setTestMethodName(element.getAttributeValue("testMethod"));
-                double duration;
-                try {
-                    duration = Double.valueOf(element.getAttributeValue("duration"));
-                } catch (NumberFormatException e) {
-                    // leave 0
-                    duration = 0;
-                }
-                tInfo.setTestDuration(duration);
-                tInfo.setTestResult(TestResult.TEST_SUCCEED);
-                build.addSuccessfulTest(tInfo);
-            }
-
-            @SuppressWarnings("unchecked")
-            final List<Element> failedTestResElements = XPath.newInstance("/response/failedTests/testResult").selectNodes(doc);
-            if (!failedTestResElements.isEmpty()) {
-                int i = 1;
-                for (Element element : failedTestResElements) {
-                    TestDetailsInfo tInfo = new TestDetailsInfo();
-                    tInfo.setTestClassName(element.getAttributeValue("testClass"));
-                    tInfo.setTestMethodName(element.getAttributeValue("testMethod"));
-                    double duration;
-                    try {
-                        duration = Double.valueOf(element.getAttributeValue("duration"));
-                    } catch (NumberFormatException e) {
-                        // leave 0
-                        duration = 0;
-                    }
-                    tInfo.setTestDuration(duration);
-                    tInfo.setTestResult(TestResult.TEST_FAILED);
-
-                    String path = "/response/failedTests/testResult[" + i++ + "]/errors/error";
-                    XPath errorPath = XPath.newInstance(path);
-                    @SuppressWarnings("unchecked")
-                    final List<Element> errorElements = errorPath.selectNodes(doc);
-                    for (Element error : errorElements) {
-                        tInfo.setTestErrors(error.getText());
-                    }
-                    build.addFailedTest(tInfo);
-                }
-            }
-
-            return build;
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-    }
-
-    public void addLabelToBuild(String buildKey, String buildNumber, String buildLabel) throws RemoteApiException {
-		String buildResultUrl;
-
-		buildResultUrl = baseUrl + ADD_LABEL_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
-				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey)
-				+ "&buildNumber=" + UrlUtil.encodeUrl(buildNumber)
-				+ "&label=" + UrlUtil.encodeUrl(buildLabel);
-
-
-		try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                throw new RemoteApiException(exception);
-            }
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-    }
-
-    public void addCommentToBuild(String buildKey, String buildNumber, String buildComment) throws RemoteApiException {
-		String buildResultUrl;
-
-		buildResultUrl = baseUrl + ADD_COMMENT_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
-				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey)
-				+ "&buildNumber=" + UrlUtil.encodeUrl(buildNumber)
-				+ "&content=" + UrlUtil.encodeUrl(buildComment);
-
-
-		try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                throw new RemoteApiException(exception);
-            }
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-    }
-
-    public void executeBuild(String buildKey) throws RemoteApiException {
-		String buildResultUrl;
-
-		buildResultUrl = baseUrl + EXECUTE_BUILD_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
-				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey);
-
-
-		try {
-            Document doc = retrieveGetResponse(buildResultUrl);
-            String exception = getExceptionMessages(doc);
-            if (null != exception) {
-                throw new RemoteApiException(exception);
-            }
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-    }
-
-    BambooBuild constructBuildErrorInfo(String planId, String message, Date lastPollingTime) {
-        BambooBuildInfo buildInfo = new BambooBuildInfo();
-
-        buildInfo.setServerUrl(baseUrl);
-        buildInfo.setBuildKey(planId);
-        buildInfo.setBuildState(BuildStatus.UNKNOWN.toString());
-        buildInfo.setMessage(message);
-        buildInfo.setPollingTime(lastPollingTime);
-
-        return buildInfo;
-    }
-
-    private BambooBuildInfo constructBuildItem(Element buildItemNode, Date lastPollingTime) throws RemoteApiException {
-        BambooBuildInfo buildInfo = new BambooBuildInfo();
-
-        buildInfo.setServerUrl(baseUrl);
-
-        buildInfo.setProjectName(getChildText(buildItemNode, "projectName"));
-        buildInfo.setBuildName(getChildText(buildItemNode, "buildName"));
-        buildInfo.setBuildKey(getChildText(buildItemNode, "buildKey"));
-        buildInfo.setBuildState(getChildText(buildItemNode, "buildState"));
-        buildInfo.setBuildNumber(getChildText(buildItemNode, "buildNumber"));
-        buildInfo.setBuildReason(getChildText(buildItemNode, "buildReason"));
-        buildInfo.setBuildDurationDescription(getChildText(buildItemNode, "buildDurationDescription"));
-        buildInfo.setBuildTestSummary(getChildText(buildItemNode, "buildTestSummary"));
-        buildInfo.setBuildCommitComment(getChildText(buildItemNode, "buildCommitComment"));
-        buildInfo.setBuildRelativeBuildDate(getChildText(buildItemNode, "buildRelativeBuildDate"));
-        try {
-            buildInfo.setBuildTestsPassed(Integer.parseInt(getChildText(buildItemNode, "successfulTestCount")));
-            buildInfo.setBuildTestsFailed(Integer.parseInt(getChildText(buildItemNode, "failedTestCount")));
-        } catch (NumberFormatException ex) {
-            throw new RemoteApiException("Invalid number", ex);
-        }
-        buildInfo.setBuildTime(parseBuildTime(getChildText(buildItemNode, "buildTime")));
-        buildInfo.setPollingTime(lastPollingTime);
-
-		return buildInfo;
-    }
-
-    private static DateTimeFormatter buildDateFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
-    private static DateTimeFormatter commitDateFormat = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ssZ");
-
-    private Date parseBuildTime(String date) {
-        return buildDateFormat.parseDateTime(date).toDate();
-    }
-
-    private Date parseCommitTime(String date) {
-        return commitDateFormat.parseDateTime(date).toDate();
-    }
-
-    private String getChildText(Element node, String childName) {
-        try {
-            return node.getChild(childName).getText();
-        } catch (Exception e) {
-            return "";
-        }
-    }
-
-    private static String getExceptionMessages(Document doc) throws JDOMException {
-        XPath xpath = XPath.newInstance("/errors/error");
-        @SuppressWarnings("unchecked")
-        List<Element> elements = xpath.selectNodes(doc);
-
-        if (elements != null && elements.size() > 0) {
-            StringBuffer exceptionMsg = new StringBuffer();
-            for (Element e : elements) {
-                exceptionMsg.append(e.getText());
-                exceptionMsg.append("\n");
-            }
-            return exceptionMsg.toString();
-        } else {
-            /* no exception */
-            return null;
-        }
-    }
-
-    public boolean isLoggedIn() {
-        return authToken != null;
-    }
-
-    public byte[] getBuildLogs(String buildKey, String buildNumber) throws RemoteApiException {
-		String buildResultUrl;
-
-		buildResultUrl = baseUrl + "/download/"
-				+ UrlUtil.encodeUrl(buildKey)
-				+ "/build_logs/" + UrlUtil.encodeUrl(buildKey)
-				+ "-" + UrlUtil.encodeUrl(buildNumber)
-				+ ".log";
-
-		try {
-            return retrieveGetResponseAsBytes(buildResultUrl);
-        } catch (JDOMException e) {
-            throw new RemoteApiException("Server returned malformed response", e);
-        } catch (IOException e) {
-            throw new RemoteApiException(e.getMessage(), e);
-        }
-    }
-
-    @Override
-    protected void adjustHttpHeader(HttpMethod method) {
-        // Bamboo does not require custom headers
-    }
-
-    @Override
-    protected void preprocessResult(Document doc) throws JDOMException, RemoteApiSessionExpiredException {
-        String error = getExceptionMessages(doc);
-        if (error != null) {
-            if (error.startsWith(AUTHENTICATION_ERROR_MESSAGE)) {
-                throw new RemoteApiSessionExpiredException("Session expired.");
-            }
-        }
-    }
-
-}
+/**
+ * Copyright (C) 2008 Atlassian
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.atlassian.theplugin.commons.bamboo.api;
+
+import com.atlassian.theplugin.commons.BambooFileInfo;
+import com.atlassian.theplugin.commons.BambooFileInfoImpl;
+import com.atlassian.theplugin.commons.bamboo.*;
+import com.atlassian.theplugin.commons.cfg.BambooServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerId;
+import com.atlassian.theplugin.commons.remoteapi.*;
+import com.atlassian.theplugin.commons.remoteapi.rest.AbstractHttpSession;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
+import com.atlassian.theplugin.commons.util.UrlUtil;
+import org.apache.commons.httpclient.HttpMethod;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.xpath.XPath;
+import org.joda.time.format.DateTimeFormat;
+import org.joda.time.format.DateTimeFormatter;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
+import java.net.URLEncoder;
+import java.net.UnknownHostException;
+import java.util.*;
+
+/*
+@todo get logs based on url: BASE_URL/download/TP-TEST/build_logs/TP-TEST-341.log
+ */
+
+/**
+ * Communication stub for Bamboo REST API.
+ */
+public class BambooSessionImpl extends AbstractHttpSession implements BambooSession {
+    private static final String LOGIN_ACTION = "/api/rest/login.action";
+    private static final String LOGOUT_ACTION = "/api/rest/logout.action";
+    private static final String LIST_PROJECT_ACTION = "/api/rest/listProjectNames.action";
+    private static final String LIST_PLAN_ACTION = "/api/rest/listBuildNames.action";
+    private static final String LATEST_BUILD_FOR_PLAN_ACTION = "/api/rest/getLatestBuildResults.action";
+    private static final String LATEST_USER_BUILDS_ACTION = "/api/rest/getLatestUserBuilds.action";
+    private static final String GET_BUILD_DETAILS_ACTION = "/api/rest/getBuildResultsDetails.action";
+    private static final String ADD_LABEL_ACTION = "/api/rest/addLabelToBuildResults.action";
+    private static final String ADD_COMMENT_ACTION = "/api/rest/addCommentToBuildResults.action";
+    private static final String EXECUTE_BUILD_ACTION = "/api/rest/executeBuild.action";
+    private static final String GET_BAMBOO_BUILD_NUMBER_ACTION = "/api/rest/getBambooBuildNumber.action";
+
+    private String authToken;
+
+    private static final String AUTHENTICATION_ERROR_MESSAGE = "User not authenticated yet, or session timed out";
+	
+    /**
+	 * For testing purposes, shouldn't be publicb
+	 * @param url
+	 * @throws RemoteApiException
+	 */
+	public BambooSessionImpl(String url) throws RemoteApiMalformedUrlException {
+		this(createServerCfg(url), new HttpSessionCallbackImpl());
+	}
+	
+    private static BambooServerCfg createServerCfg(String url) {
+    	BambooServerCfg serverCfg = new BambooServerCfg(url, new ServerId());
+		serverCfg.setUrl(url);
+		return serverCfg;
+	}
+
+	/**
+     * Public constructor for BambooSessionImpl.
+     *
+     * @param serverCfg The server configuration for this session
+	 * @param callback The callback needed for preparing HttpClient calls
+     * 
+     * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiMalformedUrlException
+     *
+     */
+    public BambooSessionImpl(BambooServerCfg serverCfg, HttpSessionCallback callback) throws RemoteApiMalformedUrlException {
+        super(serverCfg, callback);
+    }
+
+
+    /**
+     * Connects to Bamboo server instance. On successful login authentication token is returned from
+     * server and stored in Bamboo session for subsequent calls.
+     * <p/>
+     * The exception returned may have the getCause() examined for to get the actual exception reason.<br>
+     * If the exception is caused by a valid error response from the server (no IOEXception, UnknownHostException,
+     * MalformedURLException or JDOMException), the
+     * {@link com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginFailedException}
+     * is actually thrown. This may be used as a hint that the password is invalid.
+     *
+     * @param name      username defined on Bamboo server instance
+     * @param aPassword for username
+     * @throws com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginException
+     *          on connection or authentication errors
+     */
+    public void login(String name, char[] aPassword) throws RemoteApiLoginException {
+        String loginUrl;
+
+		if (name == null || aPassword == null) {
+			throw new RemoteApiLoginException("Corrupted configuration. Username or Password null");
+		}
+		String pass = String.valueOf(aPassword);
+		loginUrl = baseUrl + LOGIN_ACTION + "?username=" + UrlUtil.encodeUrl(name) + "&password="
+				+ UrlUtil.encodeUrl(pass) + "&os_username="
+				+ UrlUtil.encodeUrl(name) + "&os_password=" + UrlUtil.encodeUrl(pass);
+
+
+		try {
+            Document doc = retrieveGetResponse(loginUrl);
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                throw new RemoteApiLoginFailedException(exception);
+            }
+
+            @SuppressWarnings("unchecked")
+            final List<Element> elements = XPath.newInstance("/response/auth").selectNodes(doc);
+            if (elements == null || elements.size() == 0) {
+                throw new RemoteApiLoginException("Server did not return any authentication token");
+            }
+            if (elements.size() != 1) {
+                throw new RemoteApiLoginException("Server returned unexpected number of authentication tokens ("
+						+ elements.size() + ")");
+            }
+            this.authToken = elements.get(0).getText();
+        } catch (MalformedURLException e) {
+            throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
+        } catch (UnknownHostException e) {
+            throw new RemoteApiLoginException("Unknown host: " + e.getMessage(), e);
+        } catch (IOException e) {
+            throw new RemoteApiLoginException(e.getMessage(), e);
+        } catch (JDOMException e) {
+            throw new RemoteApiLoginException("Server returned malformed response", e);
+        } catch (RemoteApiSessionExpiredException e) {
+            throw new RemoteApiLoginException("Session expired", e);
+        } catch (IllegalArgumentException e) {
+            throw new RemoteApiLoginException("Malformed server URL: " + baseUrl, e);
+        }
+
+    }
+
+    public void logout() {
+        if (!isLoggedIn()) {
+            return;
+        }
+
+        try {
+            String logoutUrl = baseUrl + LOGOUT_ACTION + "?auth=" + URLEncoder.encode(authToken, "UTF-8");
+            retrieveGetResponse(logoutUrl);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException("URLEncoding problem", e);
+        } catch (IOException e) {
+            /* ignore errors on logout */
+        } catch (JDOMException e) {
+            /* ignore errors on logout */
+        } catch (RemoteApiSessionExpiredException e) {
+            /* ignore errors on logout */
+        }
+
+
+        authToken = null;
+        client = null;
+    }
+
+    public int getBamboBuildNumber() throws RemoteApiException {
+        String queryUrl = baseUrl + GET_BAMBOO_BUILD_NUMBER_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
+
+        try {
+            Document doc = retrieveGetResponse(queryUrl);
+
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                // error - method does nt exists (session errors handled in retrieveGetReponse
+                return -1;
+            }
+
+            XPath xpath = XPath.newInstance("/response/bambooBuildNumber");
+            @SuppressWarnings("unchecked")
+            Element element = (Element) xpath.selectSingleNode(doc);
+            if (element != null) {
+                String bNo = element.getText();
+                return Integer.parseInt(bNo);
+            }
+            return -1;
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+    }
+
+    public List<BambooProject> listProjectNames() throws RemoteApiException {
+        String buildResultUrl = baseUrl + LIST_PROJECT_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
+
+        List<BambooProject> projects = new ArrayList<BambooProject>();
+        try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+            XPath xpath = XPath.newInstance("/response/project");
+            @SuppressWarnings("unchecked")
+            List<Element> elements = xpath.selectNodes(doc);
+            if (elements != null) {
+                for (Element element : elements) {
+                    String name = element.getChild("name").getText();
+                    String key = element.getChild("key").getText();
+                    projects.add(new BambooProjectInfo(name, key));
+                }
+            }
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+
+        return projects;
+    }
+
+    public List<BambooPlan> listPlanNames() throws RemoteApiException {
+        String buildResultUrl = baseUrl + LIST_PLAN_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
+
+        List<BambooPlan> plans = new ArrayList<BambooPlan>();
+        try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+            XPath xpath = XPath.newInstance("/response/build");
+            @SuppressWarnings("unchecked")
+            List<Element> elements = xpath.selectNodes(doc);
+            if (elements != null) {
+                for (Element element : elements) {
+                    String enabledValue = element.getAttributeValue("enabled");
+                    boolean enabled = true;
+                    if (enabledValue != null) {
+                        enabled = Boolean.parseBoolean(enabledValue);
+                    }
+                    String name = element.getChild("name").getText();
+                    String key = element.getChild("key").getText();
+                    BambooPlanData plan = new BambooPlanData(name, key);
+                    plan.setEnabled(enabled);
+                    plans.add(plan);
+                }
+            }
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+
+        return plans;
+    }
+
+    /**
+     * Returns a {@link com.atlassian.theplugin.commons.bamboo.BambooBuild} information about the latest build in a plan.
+     * <p/>
+     * Returned structure contains either the information about the build or an error message if the connection fails.
+     *
+     * @param planKey ID of the plan to get info about
+     * @return Information about the last build or error message
+     */
+    public BambooBuild getLatestBuildForPlan(String planKey) throws RemoteApiSessionExpiredException {
+        String buildResultUrl = baseUrl + LATEST_BUILD_FOR_PLAN_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
+                    + "&buildKey=" + UrlUtil.encodeUrl(planKey);
+
+        try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+//			XmlUtil.printXml(doc);
+			String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                return constructBuildErrorInfo(planKey, exception, new Date());
+            }
+
+            @SuppressWarnings("unchecked")
+            final List elements = XPath.newInstance("/response").selectNodes(doc);
+            if (elements != null && !elements.isEmpty()) {
+                Element e = (Element) elements.iterator().next();
+				BambooBuildInfo build = constructBuildItem(e, new Date());
+				build.setCommiters(constructBuildCommiters(doc));
+				return build;
+            } else {
+                return constructBuildErrorInfo(planKey, "Malformed server reply: no response element", new Date());
+            }
+        } catch (IOException e) {
+            return constructBuildErrorInfo(planKey, e.getMessage(), new Date());
+        } catch (JDOMException e) {
+            return constructBuildErrorInfo(planKey, "Server returned malformed response", new Date());
+        } catch (RemoteApiException e) {
+            return constructBuildErrorInfo(planKey, e.getMessage(), new Date());
+        }
+    }
+
+	private Set<String> constructBuildCommiters(final Document doc) throws JDOMException {
+
+		Set<String> commiters = new HashSet<String>();
+		@SuppressWarnings("unchecked")
+		final List<Element> commitElements = XPath.newInstance("/response/commits/commit").selectNodes(doc);
+		if (!commitElements.isEmpty()) {
+
+			for (Element element : commitElements) {
+				commiters.add(element.getAttributeValue("author"));
+			}
+		}
+
+		return commiters;
+	}
+
+	public List<String> getFavouriteUserPlans() throws RemoteApiSessionExpiredException {
+        List<String> builds = new ArrayList<String>();
+        String buildResultUrl = baseUrl + LATEST_USER_BUILDS_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken);
+
+        try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                return builds;
+            }
+
+            final XPath xpath = XPath.newInstance("/response/build");
+            @SuppressWarnings("unchecked")
+            final List<Element> elements = xpath.selectNodes(doc);
+            if (elements != null) {
+                for (Element element : elements) {
+                    builds.add(element.getChildText("key"));
+                }
+                return builds;
+            } else {
+                return builds;
+            }
+        } catch (IOException e) {
+            return builds;
+        } catch (JDOMException e) {
+            return builds;
+        }
+    }
+
+    public BuildDetails getBuildResultDetails(String buildKey, String buildNumber) throws RemoteApiException {
+		String buildResultUrl;
+
+
+		buildResultUrl = baseUrl + GET_BUILD_DETAILS_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
+				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey)
+				+ "&buildNumber=" + UrlUtil.encodeUrl(buildNumber);
+
+
+		try {
+            BuildDetailsInfo build = new BuildDetailsInfo();
+            Document doc = retrieveGetResponse(buildResultUrl);
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                throw new RemoteApiException(exception);
+            }
+
+            @SuppressWarnings("unchecked")
+            final List<Element> responseElements = XPath.newInstance("/response").selectNodes(doc);
+            for (Element element : responseElements) {
+                String vcsRevisionKey = element.getAttributeValue("vcsRevisionKey");
+                if (vcsRevisionKey != null) {
+                    build.setVcsRevisionKey(vcsRevisionKey);
+                }
+            }
+
+            @SuppressWarnings("unchecked")
+                final List<Element> commitElements = XPath.newInstance("/response/commits/commit").selectNodes(doc);
+                if (!commitElements.isEmpty()) {
+                    int i = 1;
+                    for (Element element : commitElements) {
+                        BambooChangeSetImpl cInfo = new BambooChangeSetImpl();
+                        cInfo.setAuthor(element.getAttributeValue("author"));
+                        cInfo.setCommitDate(parseCommitTime(element.getAttributeValue("date")));
+                        cInfo.setComment(getChildText(element, "comment"));
+
+                        String path = "/response/commits/commit[" + i++ + "]/files/file";
+                        XPath filesPath = XPath.newInstance(path);
+                        @SuppressWarnings("unchecked")
+                        final List<Element> fileElements = filesPath.selectNodes(doc);
+                        for (Element file : fileElements) {
+                            BambooFileInfo fileInfo = new BambooFileInfoImpl(
+                                    cInfo.getVirtualFileSystem(),
+                                    file.getAttributeValue("name"),
+                                    file.getAttributeValue("revision"));
+                            cInfo.addCommitFile(fileInfo);
+                        }
+                        build.addCommitInfo(cInfo);
+                    }
+                }
+
+            @SuppressWarnings("unchecked")
+            final List<Element> sucTestResElements
+                    = XPath.newInstance("/response/successfulTests/testResult").selectNodes(doc);
+            for (Element element : sucTestResElements) {
+                TestDetailsInfo tInfo = new TestDetailsInfo();
+                tInfo.setTestClassName(element.getAttributeValue("testClass"));
+                tInfo.setTestMethodName(element.getAttributeValue("testMethod"));
+                double duration;
+                try {
+                    duration = Double.valueOf(element.getAttributeValue("duration"));
+                } catch (NumberFormatException e) {
+                    // leave 0
+                    duration = 0;
+                }
+                tInfo.setTestDuration(duration);
+                tInfo.setTestResult(TestResult.TEST_SUCCEED);
+                build.addSuccessfulTest(tInfo);
+            }
+
+            @SuppressWarnings("unchecked")
+            final List<Element> failedTestResElements = XPath.newInstance("/response/failedTests/testResult").selectNodes(doc);
+            if (!failedTestResElements.isEmpty()) {
+                int i = 1;
+                for (Element element : failedTestResElements) {
+                    TestDetailsInfo tInfo = new TestDetailsInfo();
+                    tInfo.setTestClassName(element.getAttributeValue("testClass"));
+                    tInfo.setTestMethodName(element.getAttributeValue("testMethod"));
+                    double duration;
+                    try {
+                        duration = Double.valueOf(element.getAttributeValue("duration"));
+                    } catch (NumberFormatException e) {
+                        // leave 0
+                        duration = 0;
+                    }
+                    tInfo.setTestDuration(duration);
+                    tInfo.setTestResult(TestResult.TEST_FAILED);
+
+                    String path = "/response/failedTests/testResult[" + i++ + "]/errors/error";
+                    XPath errorPath = XPath.newInstance(path);
+                    @SuppressWarnings("unchecked")
+                    final List<Element> errorElements = errorPath.selectNodes(doc);
+                    for (Element error : errorElements) {
+                        tInfo.setTestErrors(error.getText());
+                    }
+                    build.addFailedTest(tInfo);
+                }
+            }
+
+            return build;
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+    }
+
+    public void addLabelToBuild(String buildKey, String buildNumber, String buildLabel) throws RemoteApiException {
+		String buildResultUrl;
+
+		buildResultUrl = baseUrl + ADD_LABEL_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
+				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey)
+				+ "&buildNumber=" + UrlUtil.encodeUrl(buildNumber)
+				+ "&label=" + UrlUtil.encodeUrl(buildLabel);
+
+
+		try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                throw new RemoteApiException(exception);
+            }
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+    }
+
+    public void addCommentToBuild(String buildKey, String buildNumber, String buildComment) throws RemoteApiException {
+		String buildResultUrl;
+
+		buildResultUrl = baseUrl + ADD_COMMENT_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
+				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey)
+				+ "&buildNumber=" + UrlUtil.encodeUrl(buildNumber)
+				+ "&content=" + UrlUtil.encodeUrl(buildComment);
+
+
+		try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                throw new RemoteApiException(exception);
+            }
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+    }
+
+    public void executeBuild(String buildKey) throws RemoteApiException {
+		String buildResultUrl;
+
+		buildResultUrl = baseUrl + EXECUTE_BUILD_ACTION + "?auth=" + UrlUtil.encodeUrl(authToken)
+				+ "&buildKey=" + UrlUtil.encodeUrl(buildKey);
+
+
+		try {
+            Document doc = retrieveGetResponse(buildResultUrl);
+            String exception = getExceptionMessages(doc);
+            if (null != exception) {
+                throw new RemoteApiException(exception);
+            }
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+    }
+
+    BambooBuild constructBuildErrorInfo(String planId, String message, Date lastPollingTime) {
+        BambooBuildInfo buildInfo = new BambooBuildInfo();
+
+        buildInfo.setServerUrl(baseUrl);
+        buildInfo.setBuildKey(planId);
+        buildInfo.setBuildState(BuildStatus.UNKNOWN.toString());
+        buildInfo.setMessage(message);
+        buildInfo.setPollingTime(lastPollingTime);
+
+        return buildInfo;
+    }
+
+    private BambooBuildInfo constructBuildItem(Element buildItemNode, Date lastPollingTime) throws RemoteApiException {
+        BambooBuildInfo buildInfo = new BambooBuildInfo();
+
+        buildInfo.setServerUrl(baseUrl);
+
+        buildInfo.setProjectName(getChildText(buildItemNode, "projectName"));
+        buildInfo.setBuildName(getChildText(buildItemNode, "buildName"));
+        buildInfo.setBuildKey(getChildText(buildItemNode, "buildKey"));
+        buildInfo.setBuildState(getChildText(buildItemNode, "buildState"));
+        buildInfo.setBuildNumber(getChildText(buildItemNode, "buildNumber"));
+        buildInfo.setBuildReason(getChildText(buildItemNode, "buildReason"));
+        buildInfo.setBuildDurationDescription(getChildText(buildItemNode, "buildDurationDescription"));
+        buildInfo.setBuildTestSummary(getChildText(buildItemNode, "buildTestSummary"));
+        buildInfo.setBuildCommitComment(getChildText(buildItemNode, "buildCommitComment"));
+        buildInfo.setBuildRelativeBuildDate(getChildText(buildItemNode, "buildRelativeBuildDate"));
+        try {
+            buildInfo.setBuildTestsPassed(Integer.parseInt(getChildText(buildItemNode, "successfulTestCount")));
+            buildInfo.setBuildTestsFailed(Integer.parseInt(getChildText(buildItemNode, "failedTestCount")));
+        } catch (NumberFormatException ex) {
+            throw new RemoteApiException("Invalid number", ex);
+        }
+        buildInfo.setBuildTime(parseBuildTime(getChildText(buildItemNode, "buildTime")));
+        buildInfo.setPollingTime(lastPollingTime);
+
+		return buildInfo;
+    }
+
+    private static DateTimeFormatter buildDateFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
+    private static DateTimeFormatter commitDateFormat = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ssZ");
+
+    private Date parseBuildTime(String date) {
+        return buildDateFormat.parseDateTime(date).toDate();
+    }
+
+    private Date parseCommitTime(String date) {
+        return commitDateFormat.parseDateTime(date).toDate();
+    }
+
+    private String getChildText(Element node, String childName) {
+        try {
+            return node.getChild(childName).getText();
+        } catch (Exception e) {
+            return "";
+        }
+    }
+
+    private static String getExceptionMessages(Document doc) throws JDOMException {
+        XPath xpath = XPath.newInstance("/errors/error");
+        @SuppressWarnings("unchecked")
+        List<Element> elements = xpath.selectNodes(doc);
+
+        if (elements != null && elements.size() > 0) {
+            StringBuffer exceptionMsg = new StringBuffer();
+            for (Element e : elements) {
+                exceptionMsg.append(e.getText());
+                exceptionMsg.append("\n");
+            }
+            return exceptionMsg.toString();
+        } else {
+            /* no exception */
+            return null;
+        }
+    }
+
+    public boolean isLoggedIn() {
+        return authToken != null;
+    }
+
+    public byte[] getBuildLogs(String buildKey, String buildNumber) throws RemoteApiException {
+		String buildResultUrl;
+
+		buildResultUrl = baseUrl + "/download/"
+				+ UrlUtil.encodeUrl(buildKey)
+				+ "/build_logs/" + UrlUtil.encodeUrl(buildKey)
+				+ "-" + UrlUtil.encodeUrl(buildNumber)
+				+ ".log";
+
+		try {
+            return retrieveGetResponseAsBytes(buildResultUrl);
+        } catch (JDOMException e) {
+            throw new RemoteApiException("Server returned malformed response", e);
+        } catch (IOException e) {
+            throw new RemoteApiException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    protected void adjustHttpHeader(HttpMethod method) {
+        // Bamboo does not require custom headers
+    }
+
+    @Override
+    protected void preprocessResult(Document doc) throws JDOMException, RemoteApiSessionExpiredException {
+        String error = getExceptionMessages(doc);
+        if (error != null) {
+            if (error.startsWith(AUTHENTICATION_ERROR_MESSAGE)) {
+                throw new RemoteApiSessionExpiredException("Session expired.");
+            }
+        }
+    }
+
+}
Index: src/main/java/com/atlassian/theplugin/commons/bamboo/api/AutoRenewBambooSession.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/bamboo/api/AutoRenewBambooSession.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/bamboo/api/AutoRenewBambooSession.java	(working copy)
@@ -1,142 +1,157 @@
-/**
- * Copyright (C) 2008 Atlassian
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.atlassian.theplugin.commons.bamboo.api;
-
-import com.atlassian.theplugin.commons.bamboo.BambooPlan;
-import com.atlassian.theplugin.commons.bamboo.BambooProject;
-import com.atlassian.theplugin.commons.bamboo.BuildDetails;
-import com.atlassian.theplugin.commons.bamboo.BambooBuild;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiSessionExpiredException;
-import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginException;
-
-import java.util.List;
-
-public class AutoRenewBambooSession implements BambooSession {
-	private final BambooSession delegate;
-	private String userName;
-	private char[] password;
-
-	public AutoRenewBambooSession(String url) throws RemoteApiException {
-		this.delegate = new BambooSessionImpl(url);
-	}
-
-	public void addCommentToBuild(String buildKey, String buildNumber, String buildComment) throws RemoteApiException {
-		try {
-			delegate.addCommentToBuild(buildKey, buildNumber, buildComment);
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			delegate.addCommentToBuild(buildKey, buildNumber, buildComment);
-		}
-	}
-
-	public void executeBuild(String buildKey) throws RemoteApiException {
-		try {
-			delegate.executeBuild(buildKey);
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			delegate.executeBuild(buildKey);
-		}
-	}
-
-	public void addLabelToBuild(String buildKey, String buildNumber, String buildLabel) throws RemoteApiException {
-		try {
-			delegate.addLabelToBuild(buildKey, buildNumber, buildLabel);
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			delegate.addLabelToBuild(buildKey, buildNumber, buildLabel);
-		}
-	}
-
-	public BuildDetails getBuildResultDetails(String buildKey, String buildNumber) throws RemoteApiException {
-		try {
-			return delegate.getBuildResultDetails(buildKey, buildNumber);
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			return delegate.getBuildResultDetails(buildKey, buildNumber);
-		}					
-	}
-
-	public List<String> getFavouriteUserPlans() throws RemoteApiException {
-		try {
-			return delegate.getFavouriteUserPlans();
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			return delegate.getFavouriteUserPlans();
-		}		
-	}
-
-	public BambooBuild getLatestBuildForPlan(String planKey) throws RemoteApiException {
-		try {
-			return delegate.getLatestBuildForPlan(planKey);
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			return delegate.getLatestBuildForPlan(planKey);
-		}				
-	}
-
-	public boolean isLoggedIn() {
-		return delegate.isLoggedIn();
-	}
-
-    public byte[] getBuildLogs(String buildKey, String buildNumber) throws RemoteApiException {
-        try {
-            return delegate.getBuildLogs(buildKey, buildNumber);
-        } catch (RemoteApiSessionExpiredException e) {
-            delegate.login(userName, password);
-            return delegate.getBuildLogs(buildKey, buildNumber);
-        }
-    }
-
-    public List<BambooPlan> listPlanNames() throws RemoteApiException {
-		try {
-			return delegate.listPlanNames();
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			return delegate.listPlanNames();
-		}
-	}
-
-	public List<BambooProject> listProjectNames() throws RemoteApiException {
-		try {
-			return delegate.listProjectNames();
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			return delegate.listProjectNames();
-		}
-	}
-
-	public void login(String name, char[] aPassword) throws RemoteApiLoginException {
-		this.userName = name;
-		this.password = new char[aPassword.length];
-		System.arraycopy(aPassword, 0, password, 0, aPassword.length);
-		delegate.login(name, aPassword);
-	}
-
-	public void logout() {
-		delegate.logout();
-	}
-
-	public int getBamboBuildNumber() throws RemoteApiException {
-		try {
-			return delegate.getBamboBuildNumber();
-		} catch (RemoteApiSessionExpiredException e) {
-			delegate.login(userName, password);
-			return delegate.getBamboBuildNumber();
-		}
-	}
-}
+/**
+ * Copyright (C) 2008 Atlassian
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.atlassian.theplugin.commons.bamboo.api;
+
+import java.util.List;
+
+import com.atlassian.theplugin.commons.bamboo.BambooBuild;
+import com.atlassian.theplugin.commons.bamboo.BambooPlan;
+import com.atlassian.theplugin.commons.bamboo.BambooProject;
+import com.atlassian.theplugin.commons.bamboo.BuildDetails;
+import com.atlassian.theplugin.commons.cfg.BambooServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerId;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginException;
+import com.atlassian.theplugin.commons.remoteapi.RemoteApiSessionExpiredException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
+
+public class AutoRenewBambooSession implements BambooSession {
+	private final BambooSession delegate;
+	private String userName;
+	private char[] password;
+
+	/**
+	 * For testing purposes, shouldn't be public
+	 * @param url
+	 * @throws RemoteApiException
+	 */
+	public AutoRenewBambooSession(String url) throws RemoteApiException {
+		BambooServerCfg serverCfg = new BambooServerCfg(url, new ServerId());
+		serverCfg.setUrl(url);
+		this.delegate = new BambooSessionImpl(serverCfg, new HttpSessionCallbackImpl());
+	}
+	
+	public AutoRenewBambooSession(BambooServerCfg serverCfg, HttpSessionCallback callback) throws RemoteApiException {
+		this.delegate = new BambooSessionImpl(serverCfg, callback);
+	}
+
+	public void addCommentToBuild(String buildKey, String buildNumber, String buildComment) throws RemoteApiException {
+		try {
+			delegate.addCommentToBuild(buildKey, buildNumber, buildComment);
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			delegate.addCommentToBuild(buildKey, buildNumber, buildComment);
+		}
+	}
+
+	public void executeBuild(String buildKey) throws RemoteApiException {
+		try {
+			delegate.executeBuild(buildKey);
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			delegate.executeBuild(buildKey);
+		}
+	}
+
+	public void addLabelToBuild(String buildKey, String buildNumber, String buildLabel) throws RemoteApiException {
+		try {
+			delegate.addLabelToBuild(buildKey, buildNumber, buildLabel);
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			delegate.addLabelToBuild(buildKey, buildNumber, buildLabel);
+		}
+	}
+
+	public BuildDetails getBuildResultDetails(String buildKey, String buildNumber) throws RemoteApiException {
+		try {
+			return delegate.getBuildResultDetails(buildKey, buildNumber);
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			return delegate.getBuildResultDetails(buildKey, buildNumber);
+		}					
+	}
+
+	public List<String> getFavouriteUserPlans() throws RemoteApiException {
+		try {
+			return delegate.getFavouriteUserPlans();
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			return delegate.getFavouriteUserPlans();
+		}		
+	}
+
+	public BambooBuild getLatestBuildForPlan(String planKey) throws RemoteApiException {
+		try {
+			return delegate.getLatestBuildForPlan(planKey);
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			return delegate.getLatestBuildForPlan(planKey);
+		}				
+	}
+
+	public boolean isLoggedIn() {
+		return delegate.isLoggedIn();
+	}
+
+    public byte[] getBuildLogs(String buildKey, String buildNumber) throws RemoteApiException {
+        try {
+            return delegate.getBuildLogs(buildKey, buildNumber);
+        } catch (RemoteApiSessionExpiredException e) {
+            delegate.login(userName, password);
+            return delegate.getBuildLogs(buildKey, buildNumber);
+        }
+    }
+
+    public List<BambooPlan> listPlanNames() throws RemoteApiException {
+		try {
+			return delegate.listPlanNames();
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			return delegate.listPlanNames();
+		}
+	}
+
+	public List<BambooProject> listProjectNames() throws RemoteApiException {
+		try {
+			return delegate.listProjectNames();
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			return delegate.listProjectNames();
+		}
+	}
+
+	public void login(String name, char[] aPassword) throws RemoteApiLoginException {
+		this.userName = name;
+		this.password = new char[aPassword.length];
+		System.arraycopy(aPassword, 0, password, 0, aPassword.length);
+		delegate.login(name, aPassword);
+	}
+
+	public void logout() {
+		delegate.logout();
+	}
+
+	public int getBamboBuildNumber() throws RemoteApiException {
+		try {
+			return delegate.getBamboBuildNumber();
+		} catch (RemoteApiSessionExpiredException e) {
+			delegate.login(userName, password);
+			return delegate.getBamboBuildNumber();
+		}
+	}
+}
Index: src/main/java/com/atlassian/theplugin/commons/bamboo/BambooServerFacadeImpl.java
===================================================================
--- src/main/java/com/atlassian/theplugin/commons/bamboo/BambooServerFacadeImpl.java	(revision 24291)
+++ src/main/java/com/atlassian/theplugin/commons/bamboo/BambooServerFacadeImpl.java	(working copy)
@@ -16,19 +16,28 @@
 
 package com.atlassian.theplugin.commons.bamboo;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
 import com.atlassian.theplugin.commons.ServerType;
 import com.atlassian.theplugin.commons.SubscribedPlan;
 import com.atlassian.theplugin.commons.bamboo.api.AutoRenewBambooSession;
 import com.atlassian.theplugin.commons.bamboo.api.BambooSession;
 import com.atlassian.theplugin.commons.cfg.BambooServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerCfg;
+import com.atlassian.theplugin.commons.cfg.ServerId;
 import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
 import com.atlassian.theplugin.commons.remoteapi.RemoteApiLoginFailedException;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallback;
+import com.atlassian.theplugin.commons.remoteapi.rest.HttpSessionCallbackImpl;
 import com.atlassian.theplugin.commons.util.Logger;
 
-import java.util.*;
 
-
 /**
  * Class used for communication wiht Bamboo Server.
  * User: sginter
@@ -41,8 +50,11 @@
 
     private static BambooServerFacadeImpl instance = null;
 
+    private HttpSessionCallback callback;
+    
     private BambooServerFacadeImpl(Logger loger) {
         this.loger = loger;
+        this.callback = new HttpSessionCallbackImpl();
     }                                                                                            
 
     public static synchronized BambooServerFacade getInstance(Logger loger) {
@@ -62,7 +74,7 @@
         String key = server.getUsername() + server.getUrl() + server.getPassword();
         BambooSession session = sessions.get(key);
         if (session == null) {
-            session = new AutoRenewBambooSession(server.getUrl());
+            session = new AutoRenewBambooSession(server, callback);
             sessions.put(key, session);
         }
         if (!session.isLoggedIn()) {
@@ -82,17 +94,29 @@
     }
 
     /**
+     * For testing Only
+     * @see com.atlassian.theplugin.commons.remoteapi.ProductServerFacade#testServerConnection(java.lang.String, java.lang.String, java.lang.String)
+     */
+    public void testServerConnection(String url, String userName, String password) throws RemoteApiException {
+    	BambooServerCfg serverCfg = new BambooServerCfg(url, new ServerId());
+    	serverCfg.setUrl(url);
+    	serverCfg.setUsername(userName);
+    	serverCfg.setPassword(password);
+    	testServerConnection(serverCfg);
+    }
+    
+	/**
      * Test connection to Bamboo server.
      *
-     * @param url      Bamboo server base URL
-     * @param userName Bamboo user name
-     * @param password Bamboo password
+     * @param serverCfg The configuration for the server that we want to test the connectio for
+     * 
      * @throws RemoteApiException on failed login
      * @see RemoteApiLoginFailedException
      */
-    public void testServerConnection(String url, String userName, String password) throws RemoteApiException {
-        BambooSession apiHandler = new AutoRenewBambooSession(url);
-        apiHandler.login(userName, password.toCharArray());
+    public void testServerConnection(ServerCfg serverCfg) throws RemoteApiException {
+    	assert(serverCfg instanceof BambooServerCfg);
+    	BambooSession apiHandler = new AutoRenewBambooSession((BambooServerCfg)serverCfg, callback);
+        apiHandler.login(serverCfg.getUsername(), serverCfg.getPassword().toCharArray());
         apiHandler.logout();
     }
 
@@ -356,5 +380,8 @@
 
 		return buildInfo;
 	}
-
+    
+	public void setCallback(HttpSessionCallback callback) {
+		this.callback = callback;
+	}
 }
